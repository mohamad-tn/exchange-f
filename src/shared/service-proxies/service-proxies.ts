//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(null as any);
    }
}

@Injectable()
export class ClientServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ClientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ClientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClientDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto[]>(null as any);
    }

    /**
     * @param transactionType (optional) 
     * @param id (optional) 
     * @return Success
     */
    getBalanceForEdit(transactionType: number | undefined, id: number | undefined): Observable<ClientBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetBalanceForEdit?";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientBalanceDto>;
        }));
    }

    protected processGetBalanceForEdit(response: HttpResponseBase): Observable<ClientBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateClientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateClientDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateClientDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateClientDto | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateClientDto | undefined): Observable<ClientDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ClientDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Client/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    getCurrentBalance(clientId: number | undefined, currencyId: number | undefined): Observable<ClientBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Client/GetCurrentBalance?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientBalanceDto>;
        }));
    }

    protected processGetCurrentBalance(response: HttpResponseBase): Observable<ClientBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientBalanceDto>(null as any);
    }
}

@Injectable()
export class ClientCashFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param clientId (optional) 
     * @param currencyId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    get(clientId: number | undefined, currencyId: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined): Observable<ClientCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/Get?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientCashFlowDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ClientCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClientCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientCashFlowDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    getClientsBalances(date: string | null | undefined): Observable<ClientCashFlowTotalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/GetClientsBalances?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetClientsBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetClientsBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientCashFlowTotalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientCashFlowTotalDto[]>;
        }));
    }

    protected processGetClientsBalances(response: HttpResponseBase): Observable<ClientCashFlowTotalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClientCashFlowTotalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientCashFlowTotalDto[]>(null as any);
    }

    /**
     * @param days (optional) 
     * @return Success
     */
    getDefaulters(days: number | undefined): Observable<DefaultersOfPaymentDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/GetDefaulters?";
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaulters(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaulters(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DefaultersOfPaymentDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DefaultersOfPaymentDto[]>;
        }));
    }

    protected processGetDefaulters(response: HttpResponseBase): Observable<DefaultersOfPaymentDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DefaultersOfPaymentDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DefaultersOfPaymentDto[]>(null as any);
    }

    /**
     * @param days (optional) 
     * @return Success
     */
    getInactiveClient(days: number | undefined): Observable<InactiveClientDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/GetInactiveClient?";
        if (days === null)
            throw new Error("The parameter 'days' cannot be null.");
        else if (days !== undefined)
            url_ += "days=" + encodeURIComponent("" + days) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInactiveClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInactiveClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InactiveClientDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InactiveClientDto[]>;
        }));
    }

    protected processGetInactiveClient(response: HttpResponseBase): Observable<InactiveClientDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InactiveClientDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InactiveClientDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: CashFlowDataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param clientId (optional) 
     * @param currencyId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    getCurrentBalance(clientId: number | undefined, currencyId: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined): Observable<CurrentClientBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/GetCurrentBalance?";
        if (clientId === null)
            throw new Error("The parameter 'clientId' cannot be null.");
        else if (clientId !== undefined)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentClientBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentClientBalanceDto>;
        }));
    }

    protected processGetCurrentBalance(response: HttpResponseBase): Observable<CurrentClientBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentClientBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentClientBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    match(body: ClientCashFlowMatchingDto | undefined): Observable<ClientCashFlowMatchingDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/Match";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClientCashFlowMatchingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClientCashFlowMatchingDto>;
        }));
    }

    protected processMatch(response: HttpResponseBase): Observable<ClientCashFlowMatchingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientCashFlowMatchingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientCashFlowMatchingDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    summary(date: string | null | undefined): Observable<SummaryCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ClientCashFlow/Summary?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SummaryCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SummaryCashFlowDto[]>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<SummaryCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SummaryCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryCashFlowDto[]>(null as any);
    }
}

@Injectable()
export class CommisionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CommisionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Commision/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommisionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommisionDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CommisionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CommisionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommisionDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Commision/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateCommisionDto> {
        let url_ = this.baseUrl + "/api/services/app/Commision/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCommisionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCommisionDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateCommisionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCommisionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCommisionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCommisionDto | undefined): Observable<CommisionDto> {
        let url_ = this.baseUrl + "/api/services/app/Commision/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommisionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommisionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CommisionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommisionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommisionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCommisionDto | undefined): Observable<CommisionDto> {
        let url_ = this.baseUrl + "/api/services/app/Commision/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CommisionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CommisionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CommisionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CommisionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CommisionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Commision/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CompanyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CompanyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompanyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto[]>(null as any);
    }

    /**
     * @param transactionType (optional) 
     * @param id (optional) 
     * @return Success
     */
    getBalanceForEdit(transactionType: number | undefined, id: number | undefined): Observable<CompanyBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetBalanceForEdit?";
        if (transactionType === null)
            throw new Error("The parameter 'transactionType' cannot be null.");
        else if (transactionType !== undefined)
            url_ += "TransactionType=" + encodeURIComponent("" + transactionType) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalanceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalanceForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyBalanceDto>;
        }));
    }

    protected processGetBalanceForEdit(response: HttpResponseBase): Observable<CompanyBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param companyId (optional) 
     * @param currencyId (optional) 
     * @return Success
     */
    getCurrentBalance(companyId: number | undefined, currencyId: number | undefined): Observable<CompanyBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetCurrentBalance?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyBalanceDto>;
        }));
    }

    protected processGetCurrentBalance(response: HttpResponseBase): Observable<CompanyBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyBalanceDto>(null as any);
    }

    /**
     * @param companyId (optional) 
     * @return Success
     */
    getAllBalances(companyId: number | undefined): Observable<CompanyBalanceWithCurrencyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetAllBalances?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyBalanceWithCurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyBalanceWithCurrencyDto[]>;
        }));
    }

    protected processGetAllBalances(response: HttpResponseBase): Observable<CompanyBalanceWithCurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyBalanceWithCurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyBalanceWithCurrencyDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateCompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCompanyDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateCompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCompanyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCompanyDto | undefined): Observable<CompanyDto> {
        let url_ = this.baseUrl + "/api/services/app/Company/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Company/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CompanyCashFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param companyId (optional) 
     * @param currencyId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    get(companyId: number | undefined, currencyId: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined): Observable<CompanyCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CompanyCashFlow/Get?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyCashFlowDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompanyCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyCashFlowDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    getCompanysBalances(date: string | null | undefined): Observable<CompanyCashFlowTotalDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CompanyCashFlow/GetCompanysBalances?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanysBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanysBalances(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyCashFlowTotalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyCashFlowTotalDto[]>;
        }));
    }

    protected processGetCompanysBalances(response: HttpResponseBase): Observable<CompanyCashFlowTotalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CompanyCashFlowTotalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyCashFlowTotalDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    summary(date: string | null | undefined): Observable<SummaryCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CompanyCashFlow/Summary?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SummaryCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SummaryCashFlowDto[]>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<SummaryCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SummaryCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryCashFlowDto[]>(null as any);
    }

    /**
     * @param companyId (optional) 
     * @param currencyId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    getCurrentBalance(companyId: number | undefined, currencyId: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined): Observable<CurrentCompanyBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyCashFlow/GetCurrentBalance?";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentCompanyBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentCompanyBalanceDto>;
        }));
    }

    protected processGetCurrentBalance(response: HttpResponseBase): Observable<CurrentCompanyBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentCompanyBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentCompanyBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: CashFlowDataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyCashFlow/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    match(body: CompanyCashFlowMatchingDto | undefined): Observable<CompanyCashFlowMatchingDto> {
        let url_ = this.baseUrl + "/api/services/app/CompanyCashFlow/Match";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CompanyCashFlowMatchingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CompanyCashFlowMatchingDto>;
        }));
    }

    protected processMatch(response: HttpResponseBase): Observable<CompanyCashFlowMatchingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyCashFlowMatchingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyCashFlowMatchingDto>(null as any);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CountryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllWithDetail(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetAllWithDetail";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithDetail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetAllWithDetail(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateCountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCountryDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCountryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCountryDto | undefined): Observable<CountryDto> {
        let url_ = this.baseUrl + "/api/services/app/Country/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Country/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CurrencyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CurrencyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CurrencyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateCurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateCurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateCurrencyDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateCurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateCurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateCurrencyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateCurrencyDto | undefined): Observable<CurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateCurrencyDto | undefined): Observable<CurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<CurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto[]>(null as any);
    }

    /**
     * @param symbol (optional) 
     * @return Success
     */
    getByName(symbol: string | null | undefined): Observable<CustomerDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetByName?";
        if (symbol !== undefined && symbol !== null)
            url_ += "symbol=" + encodeURIComponent("" + symbol) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto>;
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<CustomerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto>(null as any);
    }

    /**
     * @param customerId (optional) 
     * @return Success
     */
    getCustomerImages(customerId: number | undefined): Observable<FileUploadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetCustomerImages?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadDto[]>;
        }));
    }

    protected processGetCustomerImages(response: HttpResponseBase): Observable<FileUploadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FileUploadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileUploadDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getTreasuryActionBeneficiaries(): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetTreasuryActionBeneficiaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreasuryActionBeneficiaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreasuryActionBeneficiaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CustomerDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CustomerDto[]>;
        }));
    }

    protected processGetTreasuryActionBeneficiaries(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(CustomerDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto[]>(null as any);
    }
}

@Injectable()
export class ExchangeCurrencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateExchangeCurrencyDto | undefined): Observable<CreateExchangeCurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeCurrency/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CreateExchangeCurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CreateExchangeCurrencyDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateExchangeCurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateExchangeCurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateExchangeCurrencyDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateExchangeCurrencyDto | undefined): Observable<UpdateExchangeCurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeCurrency/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateExchangeCurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateExchangeCurrencyDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateExchangeCurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateExchangeCurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateExchangeCurrencyDto>(null as any);
    }

    /**
     * @param exchangeCurrencyId (optional) 
     * @return Success
     */
    getForEdit(exchangeCurrencyId: number | undefined): Observable<UpdateExchangeCurrencyDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeCurrency/GetForEdit?";
        if (exchangeCurrencyId === null)
            throw new Error("The parameter 'exchangeCurrencyId' cannot be null.");
        else if (exchangeCurrencyId !== undefined)
            url_ += "exchangeCurrencyId=" + encodeURIComponent("" + exchangeCurrencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateExchangeCurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateExchangeCurrencyDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateExchangeCurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateExchangeCurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateExchangeCurrencyDto>(null as any);
    }

    /**
     * @return Success
     */
    getLastNumber(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeCurrency/GetLastNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLastNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: ExchangeCurrencyDataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeCurrency/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ExchangeCurrency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class ExchangePriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ExchangePriceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/ExchangePrice/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangePriceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangePriceDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ExchangePriceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExchangePriceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangePriceDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateExchangePriceDto | undefined): Observable<ExchangePriceDto> {
        let url_ = this.baseUrl + "/api/services/app/ExchangePrice/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangePriceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangePriceDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ExchangePriceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExchangePriceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangePriceDto>(null as any);
    }
}

@Injectable()
export class ExpenseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<ExpenseDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Expense/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ExpenseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExpenseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Expense/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateExpenseDto> {
        let url_ = this.baseUrl + "/api/services/app/Expense/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateExpenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateExpenseDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateExpenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateExpenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateExpenseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateExpenseDto | undefined): Observable<ExpenseDto> {
        let url_ = this.baseUrl + "/api/services/app/Expense/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ExpenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateExpenseDto | undefined): Observable<ExpenseDto> {
        let url_ = this.baseUrl + "/api/services/app/Expense/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExpenseDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExpenseDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ExpenseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExpenseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpenseDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Expense/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class GeneralSettingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPassword(body: CheckPasswordInput | undefined): Observable<CheckPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/GeneralSetting/CheckPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckPasswordOutput>;
        }));
    }

    protected processCheckPassword(response: HttpResponseBase): Observable<CheckPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckPasswordOutput>(null as any);
    }

    /**
     * @return Success
     */
    get(): Observable<GeneralSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralSetting/Get";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSettingDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GeneralSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSettingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: GeneralSettingDto | undefined): Observable<GeneralSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralSetting/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralSettingDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralSettingDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<GeneralSettingDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralSettingDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralSettingDto>(null as any);
    }
}

@Injectable()
export class IncomeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<IncomeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Income/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<IncomeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IncomeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Income/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<UpdateIncomeDto> {
        let url_ = this.baseUrl + "/api/services/app/Income/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateIncomeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateIncomeDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<UpdateIncomeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateIncomeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateIncomeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateIncomeDto | undefined): Observable<IncomeDto> {
        let url_ = this.baseUrl + "/api/services/app/Income/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IncomeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncomeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateIncomeDto | undefined): Observable<IncomeDto> {
        let url_ = this.baseUrl + "/api/services/app/Income/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IncomeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncomeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Income/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class IncomeTransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: IncomeTransferDto | undefined): Observable<IncomeTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransfer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<IncomeTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncomeTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: IncomeTransferDto | undefined): Observable<IncomeTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransfer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<IncomeTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncomeTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDto>(null as any);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param companyId (optional) 
     * @param number (optional) 
     * @return Success
     */
    getForEdit(fromDate: string | null | undefined, toDate: string | null | undefined, companyId: number | null | undefined, number: number | null | undefined): Observable<IncomeTransferDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransfer/GetForEdit?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (companyId !== undefined && companyId !== null)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (number !== undefined && number !== null)
            url_ += "number=" + encodeURIComponent("" + number) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDto[]>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<IncomeTransferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IncomeTransferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getLastNumber(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransfer/GetLastNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLastNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransfer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class IncomeTransferDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeStatus(body: IncomeTransferDetailChangeStatusInput | undefined): Observable<IncomeTransferDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/ChangeStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDetailDto>;
        }));
    }

    protected processChangeStatus(response: HttpResponseBase): Observable<IncomeTransferDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncomeTransferDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDetailDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllDirectTransfers(): Observable<IncomeTransferDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/GetAllDirectTransfers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDirectTransfers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDirectTransfers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDetailDto[]>;
        }));
    }

    protected processGetAllDirectTransfers(response: HttpResponseBase): Observable<IncomeTransferDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IncomeTransferDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDetailDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDirectTransferForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/GetDirectTransferForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDirectTransferForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDirectTransferForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetDirectTransferForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param incomeTransferDetailId (optional) 
     * @return Success
     */
    getDirectTransferImages(incomeTransferDetailId: number | undefined): Observable<FileUploadDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/GetDirectTransferImages?";
        if (incomeTransferDetailId === null)
            throw new Error("The parameter 'incomeTransferDetailId' cannot be null.");
        else if (incomeTransferDetailId !== undefined)
            url_ += "incomeTransferDetailId=" + encodeURIComponent("" + incomeTransferDetailId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDirectTransferImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDirectTransferImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileUploadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileUploadDto[]>;
        }));
    }

    protected processGetDirectTransferImages(response: HttpResponseBase): Observable<FileUploadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FileUploadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileUploadDto[]>(null as any);
    }

    /**
     * @param currencyId (optional) 
     * @return Success
     */
    getNotReceived(currencyId: number | undefined): Observable<IncomeTransferDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/GetNotReceived?";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "currencyId=" + encodeURIComponent("" + currencyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotReceived(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotReceived(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDetailDto[]>;
        }));
    }

    protected processGetNotReceived(response: HttpResponseBase): Observable<IncomeTransferDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IncomeTransferDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDetailDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getAllNotReceived(): Observable<IncomeTransferDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/GetAllNotReceived";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotReceived(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotReceived(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IncomeTransferDetailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IncomeTransferDetailDto[]>;
        }));
    }

    protected processGetAllNotReceived(response: HttpResponseBase): Observable<IncomeTransferDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(IncomeTransferDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncomeTransferDetailDto[]>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    summary(date: string | null | undefined): Observable<SummaryCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/IncomeTransferDetail/Summary?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SummaryCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SummaryCashFlowDto[]>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<SummaryCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SummaryCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryCashFlowDto[]>(null as any);
    }
}

@Injectable()
export class MigrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    migrate(name: string | null | undefined): Observable<MigrationOutput> {
        let url_ = this.baseUrl + "/api/Migration/Migrate?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMigrate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMigrate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MigrationOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MigrationOutput>;
        }));
    }

    protected processMigrate(response: HttpResponseBase): Observable<MigrationOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MigrationOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MigrationOutput>(null as any);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    clearDatabase(name: string | null | undefined): Observable<ClearDatabaseOutput> {
        let url_ = this.baseUrl + "/api/Migration/ClearDatabase?";
        if (name !== undefined && name !== null)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearDatabase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ClearDatabaseOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ClearDatabaseOutput>;
        }));
    }

    protected processClearDatabase(response: HttpResponseBase): Observable<ClearDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClearDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClearDatabaseOutput>(null as any);
    }
}

@Injectable()
export class OutgoingTransferServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: OutgoingTransferDto | undefined): Observable<OutgoingTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutgoingTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutgoingTransferDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OutgoingTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutgoingTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutgoingTransferDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: OutgoingTransferDto | undefined): Observable<OutgoingTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutgoingTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutgoingTransferDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OutgoingTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutgoingTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutgoingTransferDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param number (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param paymentType (optional) 
     * @param countryId (optional) 
     * @param clientId (optional) 
     * @param companyId (optional) 
     * @param beneficiary (optional) 
     * @param beneficiaryAddress (optional) 
     * @param sender (optional) 
     * @return Success
     */
    get(number: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined, paymentType: string | null | undefined, countryId: string | null | undefined, clientId: string | null | undefined, companyId: string | null | undefined, beneficiary: string | null | undefined, beneficiaryAddress: string | null | undefined, sender: string | null | undefined): Observable<OutgoingTransferDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/Get?";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (paymentType !== undefined && paymentType !== null)
            url_ += "PaymentType=" + encodeURIComponent("" + paymentType) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (companyId !== undefined && companyId !== null)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (beneficiary !== undefined && beneficiary !== null)
            url_ += "Beneficiary=" + encodeURIComponent("" + beneficiary) + "&";
        if (beneficiaryAddress !== undefined && beneficiaryAddress !== null)
            url_ += "BeneficiaryAddress=" + encodeURIComponent("" + beneficiaryAddress) + "&";
        if (sender !== undefined && sender !== null)
            url_ += "Sender=" + encodeURIComponent("" + sender) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutgoingTransferDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutgoingTransferDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OutgoingTransferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(OutgoingTransferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutgoingTransferDto[]>(null as any);
    }

    /**
     * @param number (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param paymentType (optional) 
     * @param countryId (optional) 
     * @param clientId (optional) 
     * @param companyId (optional) 
     * @param beneficiary (optional) 
     * @param beneficiaryAddress (optional) 
     * @param sender (optional) 
     * @return Success
     */
    getForStatment(number: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined, paymentType: string | null | undefined, countryId: string | null | undefined, clientId: string | null | undefined, companyId: string | null | undefined, beneficiary: string | null | undefined, beneficiaryAddress: string | null | undefined, sender: string | null | undefined): Observable<ReadOutgoingTransferDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/GetForStatment?";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (paymentType !== undefined && paymentType !== null)
            url_ += "PaymentType=" + encodeURIComponent("" + paymentType) + "&";
        if (countryId !== undefined && countryId !== null)
            url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
        if (clientId !== undefined && clientId !== null)
            url_ += "ClientId=" + encodeURIComponent("" + clientId) + "&";
        if (companyId !== undefined && companyId !== null)
            url_ += "CompanyId=" + encodeURIComponent("" + companyId) + "&";
        if (beneficiary !== undefined && beneficiary !== null)
            url_ += "Beneficiary=" + encodeURIComponent("" + beneficiary) + "&";
        if (beneficiaryAddress !== undefined && beneficiaryAddress !== null)
            url_ += "BeneficiaryAddress=" + encodeURIComponent("" + beneficiaryAddress) + "&";
        if (sender !== undefined && sender !== null)
            url_ += "Sender=" + encodeURIComponent("" + sender) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForStatment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForStatment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadOutgoingTransferDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadOutgoingTransferDto[]>;
        }));
    }

    protected processGetForStatment(response: HttpResponseBase): Observable<ReadOutgoingTransferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ReadOutgoingTransferDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadOutgoingTransferDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<OutgoingTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutgoingTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutgoingTransferDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<OutgoingTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutgoingTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutgoingTransferDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<OutgoingTransferDto> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OutgoingTransferDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OutgoingTransferDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<OutgoingTransferDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OutgoingTransferDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutgoingTransferDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @return Success
     */
    getLastNumber(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/OutgoingTransfer/GetLastNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLastNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class ProvinceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllForDropdown(): Observable<ProvinceForDropdownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Province/GetAllForDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllForDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProvinceForDropdownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProvinceForDropdownDto[]>;
        }));
    }

    protected processGetAllForDropdown(response: HttpResponseBase): Observable<ProvinceForDropdownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProvinceForDropdownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProvinceForDropdownDto[]>(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined && permission !== null)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleListDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleListDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleListDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleListDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleListDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionDtoListResultDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PermissionDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @return Success
     */
    getPermissions(): Observable<FlatPermissionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlatPermissionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlatPermissionDto[]>;
        }));
    }

    protected processGetPermissions(response: HttpResponseBase): Observable<FlatPermissionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FlatPermissionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlatPermissionDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<RoleDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoPagedResultDto>(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TenantDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(null as any);
    }
}

@Injectable()
export class TreasuryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    createMainTreasury(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Treasury/CreateMainTreasury";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMainTreasury(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMainTreasury(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateMainTreasury(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

@Injectable()
export class TreasuryActionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: TreasuryActionDto | undefined): Observable<TreasuryActionDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryActionDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TreasuryActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryActionDto>(null as any);
    }

    /**
     * @param number (optional) 
     * @param actionType (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param mainAccount (optional) 
     * @param currencyId (optional) 
     * @param mainAccountCompanyId (optional) 
     * @param mainAccountClientId (optional) 
     * @param expenseId (optional) 
     * @param incomeId (optional) 
     * @param incomeTransferDetailId (optional) 
     * @return Success
     */
    get(number: number | undefined, actionType: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined, mainAccount: number | undefined, currencyId: number | null | undefined, mainAccountCompanyId: number | null | undefined, mainAccountClientId: number | null | undefined, expenseId: number | null | undefined, incomeId: number | null | undefined, incomeTransferDetailId: number | null | undefined): Observable<TreasuryActionDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/Get?";
        if (number === null)
            throw new Error("The parameter 'number' cannot be null.");
        else if (number !== undefined)
            url_ += "Number=" + encodeURIComponent("" + number) + "&";
        if (actionType === null)
            throw new Error("The parameter 'actionType' cannot be null.");
        else if (actionType !== undefined)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (mainAccount === null)
            throw new Error("The parameter 'mainAccount' cannot be null.");
        else if (mainAccount !== undefined)
            url_ += "MainAccount=" + encodeURIComponent("" + mainAccount) + "&";
        if (currencyId !== undefined && currencyId !== null)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (mainAccountCompanyId !== undefined && mainAccountCompanyId !== null)
            url_ += "MainAccountCompanyId=" + encodeURIComponent("" + mainAccountCompanyId) + "&";
        if (mainAccountClientId !== undefined && mainAccountClientId !== null)
            url_ += "MainAccountClientId=" + encodeURIComponent("" + mainAccountClientId) + "&";
        if (expenseId !== undefined && expenseId !== null)
            url_ += "ExpenseId=" + encodeURIComponent("" + expenseId) + "&";
        if (incomeId !== undefined && incomeId !== null)
            url_ += "IncomeId=" + encodeURIComponent("" + incomeId) + "&";
        if (incomeTransferDetailId !== undefined && incomeTransferDetailId !== null)
            url_ += "IncomeTransferDetailId=" + encodeURIComponent("" + incomeTransferDetailId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryActionDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryActionDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TreasuryActionDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreasuryActionDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryActionDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getExchangeParties(): Observable<ExchangePartyDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/GetExchangeParties";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExchangeParties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExchangeParties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExchangePartyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExchangePartyDto[]>;
        }));
    }

    protected processGetExchangeParties(response: HttpResponseBase): Observable<ExchangePartyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExchangePartyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExchangePartyDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    payDirectTransfer(body: PayDirectTransferInputDto | undefined): Observable<TreasuryActionDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/PayDirectTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayDirectTransfer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayDirectTransfer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryActionDto>;
        }));
    }

    protected processPayDirectTransfer(response: HttpResponseBase): Observable<TreasuryActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryActionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<TreasuryActionDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryActionDto>;
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<TreasuryActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryActionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TreasuryActionDto | undefined): Observable<TreasuryActionDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryActionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryActionDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TreasuryActionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryActionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryActionDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: TreasuryActionDataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param actionType (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param mainAccount (optional) 
     * @param mainAccountCompanyId (optional) 
     * @param mainAccountClientId (optional) 
     * @param expenseId (optional) 
     * @param incomeId (optional) 
     * @param beneficiaryId (optional) 
     * @return Success
     */
    getFroStatment(actionType: number | undefined, fromDate: string | null | undefined, toDate: string | null | undefined, mainAccount: number | undefined, mainAccountCompanyId: number | null | undefined, mainAccountClientId: number | null | undefined, expenseId: number | null | undefined, incomeId: number | null | undefined, beneficiaryId: number | null | undefined): Observable<TreasuryActionStatementOutputDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/GetFroStatment?";
        if (actionType === null)
            throw new Error("The parameter 'actionType' cannot be null.");
        else if (actionType !== undefined)
            url_ += "ActionType=" + encodeURIComponent("" + actionType) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (mainAccount === null)
            throw new Error("The parameter 'mainAccount' cannot be null.");
        else if (mainAccount !== undefined)
            url_ += "MainAccount=" + encodeURIComponent("" + mainAccount) + "&";
        if (mainAccountCompanyId !== undefined && mainAccountCompanyId !== null)
            url_ += "MainAccountCompanyId=" + encodeURIComponent("" + mainAccountCompanyId) + "&";
        if (mainAccountClientId !== undefined && mainAccountClientId !== null)
            url_ += "MainAccountClientId=" + encodeURIComponent("" + mainAccountClientId) + "&";
        if (expenseId !== undefined && expenseId !== null)
            url_ += "ExpenseId=" + encodeURIComponent("" + expenseId) + "&";
        if (incomeId !== undefined && incomeId !== null)
            url_ += "IncomeId=" + encodeURIComponent("" + incomeId) + "&";
        if (beneficiaryId !== undefined && beneficiaryId !== null)
            url_ += "BeneficiaryId=" + encodeURIComponent("" + beneficiaryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFroStatment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFroStatment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryActionStatementOutputDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryActionStatementOutputDto[]>;
        }));
    }

    protected processGetFroStatment(response: HttpResponseBase): Observable<TreasuryActionStatementOutputDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreasuryActionStatementOutputDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryActionStatementOutputDto[]>(null as any);
    }

    /**
     * @return Success
     */
    getLastNumber(): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryAction/GetLastNumber";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetLastNumber(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

@Injectable()
export class TreasuryBalanceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllWithDetails(): Observable<TreasuryBalanceDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryBalance/GetAllWithDetails";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWithDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWithDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryBalanceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryBalanceDto[]>;
        }));
    }

    protected processGetAllWithDetails(response: HttpResponseBase): Observable<TreasuryBalanceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreasuryBalanceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryBalanceDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertAndGet(body: TreasuryBalanceDto | undefined): Observable<TreasuryBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryBalance/InsertAndGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertAndGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertAndGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryBalanceDto>;
        }));
    }

    protected processInsertAndGet(response: HttpResponseBase): Observable<TreasuryBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryBalanceDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAndGet(body: TreasuryBalanceDto | undefined): Observable<TreasuryBalanceDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryBalance/UpdateAndGet";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAndGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAndGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryBalanceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryBalanceDto>;
        }));
    }

    protected processUpdateAndGet(response: HttpResponseBase): Observable<TreasuryBalanceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TreasuryBalanceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryBalanceDto>(null as any);
    }
}

@Injectable()
export class TreasuryCashFlowServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param treasuryId (optional) 
     * @param currencyId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    get(treasuryId: number | undefined, currencyId: number | undefined, fromDate: moment.Moment | undefined, toDate: moment.Moment | undefined): Observable<TreasuryCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryCashFlow/Get?";
        if (treasuryId === null)
            throw new Error("The parameter 'treasuryId' cannot be null.");
        else if (treasuryId !== undefined)
            url_ += "TreasuryId=" + encodeURIComponent("" + treasuryId) + "&";
        if (currencyId === null)
            throw new Error("The parameter 'currencyId' cannot be null.");
        else if (currencyId !== undefined)
            url_ += "CurrencyId=" + encodeURIComponent("" + currencyId) + "&";
        if (fromDate === null)
            throw new Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TreasuryCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TreasuryCashFlowDto[]>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TreasuryCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(TreasuryCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TreasuryCashFlowDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryCashFlow/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    summary(date: string | null | undefined): Observable<SummaryCashFlowDto[]> {
        let url_ = this.baseUrl + "/api/services/app/TreasuryCashFlow/Summary?";
        if (date !== undefined && date !== null)
            url_ += "date=" + encodeURIComponent("" + date) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SummaryCashFlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SummaryCashFlowDto[]>;
        }));
    }

    protected processSummary(response: HttpResponseBase): Observable<SummaryCashFlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SummaryCashFlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SummaryCashFlowDto[]>(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDtoListResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDtoListResultDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDtoListResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleDtoListResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getForGrid(body: DataManagerRequest | undefined): Observable<ReadGrudDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetForGrid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForGrid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForGrid(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ReadGrudDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ReadGrudDto>;
        }));
    }

    protected processGetForGrid(response: HttpResponseBase): Observable<ReadGrudDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReadGrudDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReadGrudDto>(null as any);
    }

    /**
     * @return Success
     */
    getUsersForDropdown(): Observable<UserForDropdownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersForDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersForDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersForDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserForDropdownDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserForDropdownDto[]>;
        }));
    }

    protected processGetUsersForDropdown(response: HttpResponseBase): Observable<UserForDropdownDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(UserForDropdownDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserForDropdownDto[]>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | null | undefined, isActive: boolean | null | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoPagedResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoPagedResultDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<UserDtoPagedResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoPagedResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDtoPagedResultDto>(null as any);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ClientBalanceDto implements IClientBalanceDto {
    balance: number;
    currencyId: number;
    clientId: number;
    id: number;

    constructor(data?: IClientBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balance = _data["balance"];
            this.currencyId = _data["currencyId"];
            this.clientId = _data["clientId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balance"] = this.balance;
        data["currencyId"] = this.currencyId;
        data["clientId"] = this.clientId;
        data["id"] = this.id;
        return data;
    }

    clone(): ClientBalanceDto {
        const json = this.toJSON();
        let result = new ClientBalanceDto();
        result.init(json);
        return result;
    }
}

export interface IClientBalanceDto {
    balance: number;
    currencyId: number;
    clientId: number;
    id: number;
}

export class ClientPhoneDto implements IClientPhoneDto {
    clientId: number;
    phoneNumber: string | undefined;
    id: number;

    constructor(data?: IClientPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.phoneNumber = _data["phoneNumber"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["phoneNumber"] = this.phoneNumber;
        data["id"] = this.id;
        return data;
    }

    clone(): ClientPhoneDto {
        const json = this.toJSON();
        let result = new ClientPhoneDto();
        result.init(json);
        return result;
    }
}

export interface IClientPhoneDto {
    clientId: number;
    phoneNumber: string | undefined;
    id: number;
}

export class ClientDto implements IClientDto {
    name: string | undefined;
    address: string | undefined;
    activated: boolean;
    provinceId: number;
    clientBalances: ClientBalanceDto[] | undefined;
    clientPhones: ClientPhoneDto[] | undefined;
    id: number;

    constructor(data?: IClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"];
            this.activated = _data["activated"];
            this.provinceId = _data["provinceId"];
            if (Array.isArray(_data["clientBalances"])) {
                this.clientBalances = [] as any;
                for (let item of _data["clientBalances"])
                    this.clientBalances.push(ClientBalanceDto.fromJS(item));
            }
            if (Array.isArray(_data["clientPhones"])) {
                this.clientPhones = [] as any;
                for (let item of _data["clientPhones"])
                    this.clientPhones.push(ClientPhoneDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["activated"] = this.activated;
        data["provinceId"] = this.provinceId;
        if (Array.isArray(this.clientBalances)) {
            data["clientBalances"] = [];
            for (let item of this.clientBalances)
                data["clientBalances"].push(item.toJSON());
        }
        if (Array.isArray(this.clientPhones)) {
            data["clientPhones"] = [];
            for (let item of this.clientPhones)
                data["clientPhones"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): ClientDto {
        const json = this.toJSON();
        let result = new ClientDto();
        result.init(json);
        return result;
    }
}

export interface IClientDto {
    name: string | undefined;
    address: string | undefined;
    activated: boolean;
    provinceId: number;
    clientBalances: ClientBalanceDto[] | undefined;
    clientPhones: ClientPhoneDto[] | undefined;
    id: number;
}

export class Sort implements ISort {
    name: string | undefined;
    direction: string | undefined;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["direction"] = this.direction;
        return data;
    }

    clone(): Sort {
        const json = this.toJSON();
        let result = new Sort();
        result.init(json);
        return result;
    }
}

export interface ISort {
    name: string | undefined;
    direction: string | undefined;
}

export class SearchFilter implements ISearchFilter {
    fields: string[] | undefined;
    key: string | undefined;
    operator: string | undefined;

    constructor(data?: ISearchFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields.push(item);
            }
            this.key = _data["key"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): SearchFilter {
        data = typeof data === 'object' ? data : {};
        let result = new SearchFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item);
        }
        data["key"] = this.key;
        data["operator"] = this.operator;
        return data;
    }

    clone(): SearchFilter {
        const json = this.toJSON();
        let result = new SearchFilter();
        result.init(json);
        return result;
    }
}

export interface ISearchFilter {
    fields: string[] | undefined;
    key: string | undefined;
    operator: string | undefined;
}

export class WhereFilter implements IWhereFilter {
    field: string | undefined;
    ignoreCase: boolean;
    isComplex: boolean;
    operator: string | undefined;
    condition: string | undefined;
    value: any | undefined;
    predicates: WhereFilter[] | undefined;

    constructor(data?: IWhereFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.ignoreCase = _data["ignoreCase"];
            this.isComplex = _data["isComplex"];
            this.operator = _data["operator"];
            this.condition = _data["condition"];
            this.value = _data["value"];
            if (Array.isArray(_data["predicates"])) {
                this.predicates = [] as any;
                for (let item of _data["predicates"])
                    this.predicates.push(WhereFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WhereFilter {
        data = typeof data === 'object' ? data : {};
        let result = new WhereFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["ignoreCase"] = this.ignoreCase;
        data["isComplex"] = this.isComplex;
        data["operator"] = this.operator;
        data["condition"] = this.condition;
        data["value"] = this.value;
        if (Array.isArray(this.predicates)) {
            data["predicates"] = [];
            for (let item of this.predicates)
                data["predicates"].push(item.toJSON());
        }
        return data;
    }

    clone(): WhereFilter {
        const json = this.toJSON();
        let result = new WhereFilter();
        result.init(json);
        return result;
    }
}

export interface IWhereFilter {
    field: string | undefined;
    ignoreCase: boolean;
    isComplex: boolean;
    operator: string | undefined;
    condition: string | undefined;
    value: any | undefined;
    predicates: WhereFilter[] | undefined;
}

export class Aggregate implements IAggregate {
    field: string | undefined;
    type: string | undefined;

    constructor(data?: IAggregate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Aggregate {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["type"] = this.type;
        return data;
    }

    clone(): Aggregate {
        const json = this.toJSON();
        let result = new Aggregate();
        result.init(json);
        return result;
    }
}

export interface IAggregate {
    field: string | undefined;
    type: string | undefined;
}

export class OnDemandGroupInfo implements IOnDemandGroupInfo {
    level: number;
    skip: number;
    take: number;
    where: WhereFilter[] | undefined;

    constructor(data?: IOnDemandGroupInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.skip = _data["skip"];
            this.take = _data["take"];
            if (Array.isArray(_data["where"])) {
                this.where = [] as any;
                for (let item of _data["where"])
                    this.where.push(WhereFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OnDemandGroupInfo {
        data = typeof data === 'object' ? data : {};
        let result = new OnDemandGroupInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["skip"] = this.skip;
        data["take"] = this.take;
        if (Array.isArray(this.where)) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        return data;
    }

    clone(): OnDemandGroupInfo {
        const json = this.toJSON();
        let result = new OnDemandGroupInfo();
        result.init(json);
        return result;
    }
}

export interface IOnDemandGroupInfo {
    level: number;
    skip: number;
    take: number;
    where: WhereFilter[] | undefined;
}

export class DataManagerRequest implements IDataManagerRequest {
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;

    constructor(data?: IDataManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.antiForgery = _data["antiForgery"];
            this.requiresCounts = _data["requiresCounts"];
            this.table = _data["table"];
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group.push(item);
            }
            if (Array.isArray(_data["select"])) {
                this.select = [] as any;
                for (let item of _data["select"])
                    this.select.push(item);
            }
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand.push(item);
            }
            if (Array.isArray(_data["sorted"])) {
                this.sorted = [] as any;
                for (let item of _data["sorted"])
                    this.sorted.push(Sort.fromJS(item));
            }
            if (Array.isArray(_data["search"])) {
                this.search = [] as any;
                for (let item of _data["search"])
                    this.search.push(SearchFilter.fromJS(item));
            }
            if (Array.isArray(_data["where"])) {
                this.where = [] as any;
                for (let item of _data["where"])
                    this.where.push(WhereFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates.push(Aggregate.fromJS(item));
            }
            this.onDemandGroupInfo = _data["onDemandGroupInfo"] ? OnDemandGroupInfo.fromJS(_data["onDemandGroupInfo"]) : <any>undefined;
            this.isLazyLoad = _data["isLazyLoad"];
        }
    }

    static fromJS(data: any): DataManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DataManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["antiForgery"] = this.antiForgery;
        data["requiresCounts"] = this.requiresCounts;
        data["table"] = this.table;
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.select)) {
            data["select"] = [];
            for (let item of this.select)
                data["select"].push(item);
        }
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.sorted)) {
            data["sorted"] = [];
            for (let item of this.sorted)
                data["sorted"].push(item.toJSON());
        }
        if (Array.isArray(this.search)) {
            data["search"] = [];
            for (let item of this.search)
                data["search"].push(item.toJSON());
        }
        if (Array.isArray(this.where)) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["onDemandGroupInfo"] = this.onDemandGroupInfo ? this.onDemandGroupInfo.toJSON() : <any>undefined;
        data["isLazyLoad"] = this.isLazyLoad;
        return data;
    }

    clone(): DataManagerRequest {
        const json = this.toJSON();
        let result = new DataManagerRequest();
        result.init(json);
        return result;
    }
}

export interface IDataManagerRequest {
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;
}

export class ReadGrudDto implements IReadGrudDto {
    count: number;
    result: any[] | undefined;
    groupDs: any[] | undefined;

    constructor(data?: IReadGrudDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.count = _data["count"];
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result.push(item);
            }
            if (Array.isArray(_data["groupDs"])) {
                this.groupDs = [] as any;
                for (let item of _data["groupDs"])
                    this.groupDs.push(item);
            }
        }
    }

    static fromJS(data: any): ReadGrudDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadGrudDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item);
        }
        if (Array.isArray(this.groupDs)) {
            data["groupDs"] = [];
            for (let item of this.groupDs)
                data["groupDs"].push(item);
        }
        return data;
    }

    clone(): ReadGrudDto {
        const json = this.toJSON();
        let result = new ReadGrudDto();
        result.init(json);
        return result;
    }
}

export interface IReadGrudDto {
    count: number;
    result: any[] | undefined;
    groupDs: any[] | undefined;
}

export class UpdateClientDto implements IUpdateClientDto {
    name: string | undefined;
    address: string | undefined;
    activated: boolean;
    provinceId: number;
    clientBalances: ClientBalanceDto[] | undefined;
    clientPhones: ClientPhoneDto[] | undefined;
    id: number;

    constructor(data?: IUpdateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"];
            this.activated = _data["activated"];
            this.provinceId = _data["provinceId"];
            if (Array.isArray(_data["clientBalances"])) {
                this.clientBalances = [] as any;
                for (let item of _data["clientBalances"])
                    this.clientBalances.push(ClientBalanceDto.fromJS(item));
            }
            if (Array.isArray(_data["clientPhones"])) {
                this.clientPhones = [] as any;
                for (let item of _data["clientPhones"])
                    this.clientPhones.push(ClientPhoneDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["activated"] = this.activated;
        data["provinceId"] = this.provinceId;
        if (Array.isArray(this.clientBalances)) {
            data["clientBalances"] = [];
            for (let item of this.clientBalances)
                data["clientBalances"].push(item.toJSON());
        }
        if (Array.isArray(this.clientPhones)) {
            data["clientPhones"] = [];
            for (let item of this.clientPhones)
                data["clientPhones"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateClientDto {
        const json = this.toJSON();
        let result = new UpdateClientDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateClientDto {
    name: string | undefined;
    address: string | undefined;
    activated: boolean;
    provinceId: number;
    clientBalances: ClientBalanceDto[] | undefined;
    clientPhones: ClientPhoneDto[] | undefined;
    id: number;
}

export class CreateClientDto implements ICreateClientDto {
    name: string | undefined;
    address: string | undefined;
    activated: boolean;
    provinceId: number;
    clientBalances: ClientBalanceDto[] | undefined;
    clientPhones: ClientPhoneDto[] | undefined;
    id: number;

    constructor(data?: ICreateClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"];
            this.activated = _data["activated"];
            this.provinceId = _data["provinceId"];
            if (Array.isArray(_data["clientBalances"])) {
                this.clientBalances = [] as any;
                for (let item of _data["clientBalances"])
                    this.clientBalances.push(ClientBalanceDto.fromJS(item));
            }
            if (Array.isArray(_data["clientPhones"])) {
                this.clientPhones = [] as any;
                for (let item of _data["clientPhones"])
                    this.clientPhones.push(ClientPhoneDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["activated"] = this.activated;
        data["provinceId"] = this.provinceId;
        if (Array.isArray(this.clientBalances)) {
            data["clientBalances"] = [];
            for (let item of this.clientBalances)
                data["clientBalances"].push(item.toJSON());
        }
        if (Array.isArray(this.clientPhones)) {
            data["clientPhones"] = [];
            for (let item of this.clientPhones)
                data["clientPhones"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CreateClientDto {
        const json = this.toJSON();
        let result = new CreateClientDto();
        result.init(json);
        return result;
    }
}

export interface ICreateClientDto {
    name: string | undefined;
    address: string | undefined;
    activated: boolean;
    provinceId: number;
    clientBalances: ClientBalanceDto[] | undefined;
    clientPhones: ClientPhoneDto[] | undefined;
    id: number;
}

export class CurrencyDto implements ICurrencyDto {
    name: string | undefined;
    isMainCurrency: boolean;
    id: number;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isMainCurrency = _data["isMainCurrency"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isMainCurrency"] = this.isMainCurrency;
        data["id"] = this.id;
        return data;
    }

    clone(): CurrencyDto {
        const json = this.toJSON();
        let result = new CurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICurrencyDto {
    name: string | undefined;
    isMainCurrency: boolean;
    id: number;
}

export class CashFlowMatchingDto implements ICashFlowMatchingDto {
    matchingBy: string | undefined;
    matchingWith: string | undefined;
    description: string | undefined;

    constructor(data?: ICashFlowMatchingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchingBy = _data["matchingBy"];
            this.matchingWith = _data["matchingWith"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CashFlowMatchingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowMatchingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchingBy"] = this.matchingBy;
        data["matchingWith"] = this.matchingWith;
        data["description"] = this.description;
        return data;
    }

    clone(): CashFlowMatchingDto {
        const json = this.toJSON();
        let result = new CashFlowMatchingDto();
        result.init(json);
        return result;
    }
}

export interface ICashFlowMatchingDto {
    matchingBy: string | undefined;
    matchingWith: string | undefined;
    description: string | undefined;
}

export class ClientCashFlowDto implements IClientCashFlowDto {
    clientId: number;
    client: ClientDto;
    commission: number;
    clientCommission: number;
    balance: number;
    creatorUserId: number | undefined;
    creatorUser: string | undefined;
    date: moment.Moment | undefined;
    amount: number;
    currentBalance: number;
    transactionId: number;
    transactionType: number;
    matched: boolean;
    shaded: boolean | undefined;
    type: string | undefined;
    note: string | undefined;
    instrumentNo: string | undefined;
    currencyId: number;
    currency: CurrencyDto;
    cashFlowMatchingId: number | undefined;
    cashFlowMatching: CashFlowMatchingDto;
    id: number;

    constructor(data?: IClientCashFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.client = _data["client"] ? ClientDto.fromJS(_data["client"]) : <any>undefined;
            this.commission = _data["commission"];
            this.clientCommission = _data["clientCommission"];
            this.balance = _data["balance"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUser = _data["creatorUser"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.currentBalance = _data["currentBalance"];
            this.transactionId = _data["transactionId"];
            this.transactionType = _data["transactionType"];
            this.matched = _data["matched"];
            this.shaded = _data["shaded"];
            this.type = _data["type"];
            this.note = _data["note"];
            this.instrumentNo = _data["instrumentNo"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.cashFlowMatchingId = _data["cashFlowMatchingId"];
            this.cashFlowMatching = _data["cashFlowMatching"] ? CashFlowMatchingDto.fromJS(_data["cashFlowMatching"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ClientCashFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCashFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["commission"] = this.commission;
        data["clientCommission"] = this.clientCommission;
        data["balance"] = this.balance;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUser"] = this.creatorUser;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["currentBalance"] = this.currentBalance;
        data["transactionId"] = this.transactionId;
        data["transactionType"] = this.transactionType;
        data["matched"] = this.matched;
        data["shaded"] = this.shaded;
        data["type"] = this.type;
        data["note"] = this.note;
        data["instrumentNo"] = this.instrumentNo;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["cashFlowMatchingId"] = this.cashFlowMatchingId;
        data["cashFlowMatching"] = this.cashFlowMatching ? this.cashFlowMatching.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ClientCashFlowDto {
        const json = this.toJSON();
        let result = new ClientCashFlowDto();
        result.init(json);
        return result;
    }
}

export interface IClientCashFlowDto {
    clientId: number;
    client: ClientDto;
    commission: number;
    clientCommission: number;
    balance: number;
    creatorUserId: number | undefined;
    creatorUser: string | undefined;
    date: moment.Moment | undefined;
    amount: number;
    currentBalance: number;
    transactionId: number;
    transactionType: number;
    matched: boolean;
    shaded: boolean | undefined;
    type: string | undefined;
    note: string | undefined;
    instrumentNo: string | undefined;
    currencyId: number;
    currency: CurrencyDto;
    cashFlowMatchingId: number | undefined;
    cashFlowMatching: CashFlowMatchingDto;
    id: number;
}

export class ClientCashFlowTotalDetailDto implements IClientCashFlowTotalDetailDto {
    currentBalance: number;
    currencyId: number;
    currencyName: string | undefined;

    constructor(data?: IClientCashFlowTotalDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentBalance = _data["currentBalance"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): ClientCashFlowTotalDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCashFlowTotalDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentBalance"] = this.currentBalance;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        return data;
    }

    clone(): ClientCashFlowTotalDetailDto {
        const json = this.toJSON();
        let result = new ClientCashFlowTotalDetailDto();
        result.init(json);
        return result;
    }
}

export interface IClientCashFlowTotalDetailDto {
    currentBalance: number;
    currencyId: number;
    currencyName: string | undefined;
}

export class ClientCashFlowTotalDto implements IClientCashFlowTotalDto {
    clientId: number;
    clientName: string | undefined;
    isActiveToday: boolean;
    isMatching: boolean;
    currencyBalances: ClientCashFlowTotalDetailDto[] | undefined;

    constructor(data?: IClientCashFlowTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.isActiveToday = _data["isActiveToday"];
            this.isMatching = _data["isMatching"];
            if (Array.isArray(_data["currencyBalances"])) {
                this.currencyBalances = [] as any;
                for (let item of _data["currencyBalances"])
                    this.currencyBalances.push(ClientCashFlowTotalDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientCashFlowTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCashFlowTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["isActiveToday"] = this.isActiveToday;
        data["isMatching"] = this.isMatching;
        if (Array.isArray(this.currencyBalances)) {
            data["currencyBalances"] = [];
            for (let item of this.currencyBalances)
                data["currencyBalances"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClientCashFlowTotalDto {
        const json = this.toJSON();
        let result = new ClientCashFlowTotalDto();
        result.init(json);
        return result;
    }
}

export interface IClientCashFlowTotalDto {
    clientId: number;
    clientName: string | undefined;
    isActiveToday: boolean;
    isMatching: boolean;
    currencyBalances: ClientCashFlowTotalDetailDto[] | undefined;
}

export class DefaultersOfPaymentDto implements IDefaultersOfPaymentDto {
    clientId: number;
    clientName: string | undefined;
    currencyBalances: ClientCashFlowTotalDetailDto[] | undefined;
    lastActionDate: moment.Moment | undefined;

    constructor(data?: IDefaultersOfPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            if (Array.isArray(_data["currencyBalances"])) {
                this.currencyBalances = [] as any;
                for (let item of _data["currencyBalances"])
                    this.currencyBalances.push(ClientCashFlowTotalDetailDto.fromJS(item));
            }
            this.lastActionDate = _data["lastActionDate"] ? moment(_data["lastActionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DefaultersOfPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DefaultersOfPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        if (Array.isArray(this.currencyBalances)) {
            data["currencyBalances"] = [];
            for (let item of this.currencyBalances)
                data["currencyBalances"].push(item.toJSON());
        }
        data["lastActionDate"] = this.lastActionDate ? this.lastActionDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): DefaultersOfPaymentDto {
        const json = this.toJSON();
        let result = new DefaultersOfPaymentDto();
        result.init(json);
        return result;
    }
}

export interface IDefaultersOfPaymentDto {
    clientId: number;
    clientName: string | undefined;
    currencyBalances: ClientCashFlowTotalDetailDto[] | undefined;
    lastActionDate: moment.Moment | undefined;
}

export class InactiveClientDto implements IInactiveClientDto {
    clientId: number;
    clientName: string | undefined;
    lastActionDate: moment.Moment | undefined;

    constructor(data?: IInactiveClientDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientName = _data["clientName"];
            this.lastActionDate = _data["lastActionDate"] ? moment(_data["lastActionDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InactiveClientDto {
        data = typeof data === 'object' ? data : {};
        let result = new InactiveClientDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientName"] = this.clientName;
        data["lastActionDate"] = this.lastActionDate ? this.lastActionDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): InactiveClientDto {
        const json = this.toJSON();
        let result = new InactiveClientDto();
        result.init(json);
        return result;
    }
}

export interface IInactiveClientDto {
    clientId: number;
    clientName: string | undefined;
    lastActionDate: moment.Moment | undefined;
}

export class CashFlowDataManagerRequest implements ICashFlowDataManagerRequest {
    id: number;
    currencyId: number;
    fromDate: string | undefined;
    toDate: string | undefined;
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;

    constructor(data?: ICashFlowDataManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyId = _data["currencyId"];
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.antiForgery = _data["antiForgery"];
            this.requiresCounts = _data["requiresCounts"];
            this.table = _data["table"];
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group.push(item);
            }
            if (Array.isArray(_data["select"])) {
                this.select = [] as any;
                for (let item of _data["select"])
                    this.select.push(item);
            }
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand.push(item);
            }
            if (Array.isArray(_data["sorted"])) {
                this.sorted = [] as any;
                for (let item of _data["sorted"])
                    this.sorted.push(Sort.fromJS(item));
            }
            if (Array.isArray(_data["search"])) {
                this.search = [] as any;
                for (let item of _data["search"])
                    this.search.push(SearchFilter.fromJS(item));
            }
            if (Array.isArray(_data["where"])) {
                this.where = [] as any;
                for (let item of _data["where"])
                    this.where.push(WhereFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates.push(Aggregate.fromJS(item));
            }
            this.onDemandGroupInfo = _data["onDemandGroupInfo"] ? OnDemandGroupInfo.fromJS(_data["onDemandGroupInfo"]) : <any>undefined;
            this.isLazyLoad = _data["isLazyLoad"];
        }
    }

    static fromJS(data: any): CashFlowDataManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CashFlowDataManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyId"] = this.currencyId;
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["antiForgery"] = this.antiForgery;
        data["requiresCounts"] = this.requiresCounts;
        data["table"] = this.table;
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.select)) {
            data["select"] = [];
            for (let item of this.select)
                data["select"].push(item);
        }
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.sorted)) {
            data["sorted"] = [];
            for (let item of this.sorted)
                data["sorted"].push(item.toJSON());
        }
        if (Array.isArray(this.search)) {
            data["search"] = [];
            for (let item of this.search)
                data["search"].push(item.toJSON());
        }
        if (Array.isArray(this.where)) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["onDemandGroupInfo"] = this.onDemandGroupInfo ? this.onDemandGroupInfo.toJSON() : <any>undefined;
        data["isLazyLoad"] = this.isLazyLoad;
        return data;
    }

    clone(): CashFlowDataManagerRequest {
        const json = this.toJSON();
        let result = new CashFlowDataManagerRequest();
        result.init(json);
        return result;
    }
}

export interface ICashFlowDataManagerRequest {
    id: number;
    currencyId: number;
    fromDate: string | undefined;
    toDate: string | undefined;
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;
}

export class CurrentClientBalanceDto implements ICurrentClientBalanceDto {
    client: ClientDto;
    currency: CurrencyDto;
    balance: number;

    constructor(data?: ICurrentClientBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.client = _data["client"] ? ClientDto.fromJS(_data["client"]) : <any>undefined;
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CurrentClientBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentClientBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["client"] = this.client ? this.client.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): CurrentClientBalanceDto {
        const json = this.toJSON();
        let result = new CurrentClientBalanceDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentClientBalanceDto {
    client: ClientDto;
    currency: CurrencyDto;
    balance: number;
}

export class MatchingItemDto implements IMatchingItemDto {
    id: number;
    matched: boolean;

    constructor(data?: IMatchingItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.matched = _data["matched"];
        }
    }

    static fromJS(data: any): MatchingItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new MatchingItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["matched"] = this.matched;
        return data;
    }

    clone(): MatchingItemDto {
        const json = this.toJSON();
        let result = new MatchingItemDto();
        result.init(json);
        return result;
    }
}

export interface IMatchingItemDto {
    id: number;
    matched: boolean;
}

export class ClientCashFlowMatchingDto implements IClientCashFlowMatchingDto {
    matchingBy: string | undefined;
    matchingWith: string | undefined;
    description: string | undefined;
    items: MatchingItemDto[] | undefined;

    constructor(data?: IClientCashFlowMatchingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchingBy = _data["matchingBy"];
            this.matchingWith = _data["matchingWith"];
            this.description = _data["description"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MatchingItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientCashFlowMatchingDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientCashFlowMatchingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchingBy"] = this.matchingBy;
        data["matchingWith"] = this.matchingWith;
        data["description"] = this.description;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ClientCashFlowMatchingDto {
        const json = this.toJSON();
        let result = new ClientCashFlowMatchingDto();
        result.init(json);
        return result;
    }
}

export interface IClientCashFlowMatchingDto {
    matchingBy: string | undefined;
    matchingWith: string | undefined;
    description: string | undefined;
    items: MatchingItemDto[] | undefined;
}

export class SummaryCashFlowDto implements ISummaryCashFlowDto {
    currency: CurrencyDto;
    totalBalance: number;

    constructor(data?: ISummaryCashFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.totalBalance = _data["totalBalance"];
        }
    }

    static fromJS(data: any): SummaryCashFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new SummaryCashFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["totalBalance"] = this.totalBalance;
        return data;
    }

    clone(): SummaryCashFlowDto {
        const json = this.toJSON();
        let result = new SummaryCashFlowDto();
        result.init(json);
        return result;
    }
}

export interface ISummaryCashFlowDto {
    currency: CurrencyDto;
    totalBalance: number;
}

export class CommisionDto implements ICommisionDto {
    from: number;
    to: number;
    value: number;
    percentage: number;
    currencyId: number;
    currency: CurrencyDto;
    id: number;

    constructor(data?: ICommisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.value = _data["value"];
            this.percentage = _data["percentage"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CommisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["value"] = this.value;
        data["percentage"] = this.percentage;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): CommisionDto {
        const json = this.toJSON();
        let result = new CommisionDto();
        result.init(json);
        return result;
    }
}

export interface ICommisionDto {
    from: number;
    to: number;
    value: number;
    percentage: number;
    currencyId: number;
    currency: CurrencyDto;
    id: number;
}

export class UpdateCommisionDto implements IUpdateCommisionDto {
    from: number;
    to: number;
    value: number;
    percentage: number;
    currencyId: number;
    id: number;

    constructor(data?: IUpdateCommisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.value = _data["value"];
            this.percentage = _data["percentage"];
            this.currencyId = _data["currencyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCommisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["value"] = this.value;
        data["percentage"] = this.percentage;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCommisionDto {
        const json = this.toJSON();
        let result = new UpdateCommisionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCommisionDto {
    from: number;
    to: number;
    value: number;
    percentage: number;
    currencyId: number;
    id: number;
}

export class CreateCommisionDto implements ICreateCommisionDto {
    from: number;
    to: number;
    value: number;
    percentage: number;
    currencyId: number;

    constructor(data?: ICreateCommisionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.value = _data["value"];
            this.percentage = _data["percentage"];
            this.currencyId = _data["currencyId"];
        }
    }

    static fromJS(data: any): CreateCommisionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommisionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["value"] = this.value;
        data["percentage"] = this.percentage;
        data["currencyId"] = this.currencyId;
        return data;
    }

    clone(): CreateCommisionDto {
        const json = this.toJSON();
        let result = new CreateCommisionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCommisionDto {
    from: number;
    to: number;
    value: number;
    percentage: number;
    currencyId: number;
}

export class CompanyBalanceDto implements ICompanyBalanceDto {
    balance: number;
    companyId: number;
    currencyId: number;
    id: number;

    constructor(data?: ICompanyBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balance = _data["balance"];
            this.companyId = _data["companyId"];
            this.currencyId = _data["currencyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balance"] = this.balance;
        data["companyId"] = this.companyId;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyBalanceDto {
        const json = this.toJSON();
        let result = new CompanyBalanceDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyBalanceDto {
    balance: number;
    companyId: number;
    currencyId: number;
    id: number;
}

export class CompanyDto implements ICompanyDto {
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    companyBalances: CompanyBalanceDto[] | undefined;
    id: number;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            if (Array.isArray(_data["companyBalances"])) {
                this.companyBalances = [] as any;
                for (let item of _data["companyBalances"])
                    this.companyBalances.push(CompanyBalanceDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        if (Array.isArray(this.companyBalances)) {
            data["companyBalances"] = [];
            for (let item of this.companyBalances)
                data["companyBalances"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyDto {
        const json = this.toJSON();
        let result = new CompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyDto {
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    companyBalances: CompanyBalanceDto[] | undefined;
    id: number;
}

export class CompanyBalanceWithCurrencyDto implements ICompanyBalanceWithCurrencyDto {
    balance: number;
    companyId: number;
    currencyId: number;
    currencyName: string | undefined;
    id: number;

    constructor(data?: ICompanyBalanceWithCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.balance = _data["balance"];
            this.companyId = _data["companyId"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyBalanceWithCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyBalanceWithCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["balance"] = this.balance;
        data["companyId"] = this.companyId;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyBalanceWithCurrencyDto {
        const json = this.toJSON();
        let result = new CompanyBalanceWithCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyBalanceWithCurrencyDto {
    balance: number;
    companyId: number;
    currencyId: number;
    currencyName: string | undefined;
    id: number;
}

export class UpdateCompanyDto implements IUpdateCompanyDto {
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    companyBalances: CompanyBalanceDto[] | undefined;
    id: number;

    constructor(data?: IUpdateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            if (Array.isArray(_data["companyBalances"])) {
                this.companyBalances = [] as any;
                for (let item of _data["companyBalances"])
                    this.companyBalances.push(CompanyBalanceDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        if (Array.isArray(this.companyBalances)) {
            data["companyBalances"] = [];
            for (let item of this.companyBalances)
                data["companyBalances"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCompanyDto {
        const json = this.toJSON();
        let result = new UpdateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCompanyDto {
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    companyBalances: CompanyBalanceDto[] | undefined;
    id: number;
}

export class CreateCompanyDto implements ICreateCompanyDto {
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    companyBalances: CompanyBalanceDto[] | undefined;

    constructor(data?: ICreateCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            if (Array.isArray(_data["companyBalances"])) {
                this.companyBalances = [] as any;
                for (let item of _data["companyBalances"])
                    this.companyBalances.push(CompanyBalanceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["phone"] = this.phone;
        data["address"] = this.address;
        if (Array.isArray(this.companyBalances)) {
            data["companyBalances"] = [];
            for (let item of this.companyBalances)
                data["companyBalances"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateCompanyDto {
        const json = this.toJSON();
        let result = new CreateCompanyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCompanyDto {
    name: string | undefined;
    phone: string | undefined;
    address: string | undefined;
    companyBalances: CompanyBalanceDto[] | undefined;
}

export class CompanyCashFlowDto implements ICompanyCashFlowDto {
    companyId: number;
    company: CompanyDto;
    commission: number;
    companyCommission: number;
    balance: number;
    creatorUserId: number | undefined;
    creatorUser: string | undefined;
    date: moment.Moment | undefined;
    amount: number;
    currentBalance: number;
    transactionId: number;
    transactionType: number;
    matched: boolean;
    shaded: boolean | undefined;
    type: string | undefined;
    note: string | undefined;
    instrumentNo: string | undefined;
    currencyId: number;
    currency: CurrencyDto;
    cashFlowMatchingId: number | undefined;
    cashFlowMatching: CashFlowMatchingDto;
    id: number;

    constructor(data?: ICompanyCashFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.commission = _data["commission"];
            this.companyCommission = _data["companyCommission"];
            this.balance = _data["balance"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUser = _data["creatorUser"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.currentBalance = _data["currentBalance"];
            this.transactionId = _data["transactionId"];
            this.transactionType = _data["transactionType"];
            this.matched = _data["matched"];
            this.shaded = _data["shaded"];
            this.type = _data["type"];
            this.note = _data["note"];
            this.instrumentNo = _data["instrumentNo"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.cashFlowMatchingId = _data["cashFlowMatchingId"];
            this.cashFlowMatching = _data["cashFlowMatching"] ? CashFlowMatchingDto.fromJS(_data["cashFlowMatching"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CompanyCashFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCashFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["commission"] = this.commission;
        data["companyCommission"] = this.companyCommission;
        data["balance"] = this.balance;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUser"] = this.creatorUser;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["currentBalance"] = this.currentBalance;
        data["transactionId"] = this.transactionId;
        data["transactionType"] = this.transactionType;
        data["matched"] = this.matched;
        data["shaded"] = this.shaded;
        data["type"] = this.type;
        data["note"] = this.note;
        data["instrumentNo"] = this.instrumentNo;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["cashFlowMatchingId"] = this.cashFlowMatchingId;
        data["cashFlowMatching"] = this.cashFlowMatching ? this.cashFlowMatching.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): CompanyCashFlowDto {
        const json = this.toJSON();
        let result = new CompanyCashFlowDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyCashFlowDto {
    companyId: number;
    company: CompanyDto;
    commission: number;
    companyCommission: number;
    balance: number;
    creatorUserId: number | undefined;
    creatorUser: string | undefined;
    date: moment.Moment | undefined;
    amount: number;
    currentBalance: number;
    transactionId: number;
    transactionType: number;
    matched: boolean;
    shaded: boolean | undefined;
    type: string | undefined;
    note: string | undefined;
    instrumentNo: string | undefined;
    currencyId: number;
    currency: CurrencyDto;
    cashFlowMatchingId: number | undefined;
    cashFlowMatching: CashFlowMatchingDto;
    id: number;
}

export class CompanyCashFlowTotalDetailDto implements ICompanyCashFlowTotalDetailDto {
    currentBalance: number;
    currencyId: number;
    currencyName: string | undefined;

    constructor(data?: ICompanyCashFlowTotalDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentBalance = _data["currentBalance"];
            this.currencyId = _data["currencyId"];
            this.currencyName = _data["currencyName"];
        }
    }

    static fromJS(data: any): CompanyCashFlowTotalDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCashFlowTotalDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentBalance"] = this.currentBalance;
        data["currencyId"] = this.currencyId;
        data["currencyName"] = this.currencyName;
        return data;
    }

    clone(): CompanyCashFlowTotalDetailDto {
        const json = this.toJSON();
        let result = new CompanyCashFlowTotalDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyCashFlowTotalDetailDto {
    currentBalance: number;
    currencyId: number;
    currencyName: string | undefined;
}

export class CompanyCashFlowTotalDto implements ICompanyCashFlowTotalDto {
    companyId: number;
    companyName: string | undefined;
    isActiveToday: boolean;
    isMatching: boolean;
    currencyBalances: CompanyCashFlowTotalDetailDto[] | undefined;

    constructor(data?: ICompanyCashFlowTotalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            this.companyName = _data["companyName"];
            this.isActiveToday = _data["isActiveToday"];
            this.isMatching = _data["isMatching"];
            if (Array.isArray(_data["currencyBalances"])) {
                this.currencyBalances = [] as any;
                for (let item of _data["currencyBalances"])
                    this.currencyBalances.push(CompanyCashFlowTotalDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyCashFlowTotalDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCashFlowTotalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        data["companyName"] = this.companyName;
        data["isActiveToday"] = this.isActiveToday;
        data["isMatching"] = this.isMatching;
        if (Array.isArray(this.currencyBalances)) {
            data["currencyBalances"] = [];
            for (let item of this.currencyBalances)
                data["currencyBalances"].push(item.toJSON());
        }
        return data;
    }

    clone(): CompanyCashFlowTotalDto {
        const json = this.toJSON();
        let result = new CompanyCashFlowTotalDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyCashFlowTotalDto {
    companyId: number;
    companyName: string | undefined;
    isActiveToday: boolean;
    isMatching: boolean;
    currencyBalances: CompanyCashFlowTotalDetailDto[] | undefined;
}

export class CurrentCompanyBalanceDto implements ICurrentCompanyBalanceDto {
    company: CompanyDto;
    currency: CurrencyDto;
    balance: number;

    constructor(data?: ICurrentCompanyBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CurrentCompanyBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentCompanyBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["balance"] = this.balance;
        return data;
    }

    clone(): CurrentCompanyBalanceDto {
        const json = this.toJSON();
        let result = new CurrentCompanyBalanceDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentCompanyBalanceDto {
    company: CompanyDto;
    currency: CurrencyDto;
    balance: number;
}

export class CompanyCashFlowMatchingDto implements ICompanyCashFlowMatchingDto {
    matchingBy: string | undefined;
    matchingWith: string | undefined;
    description: string | undefined;
    items: MatchingItemDto[] | undefined;

    constructor(data?: ICompanyCashFlowMatchingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.matchingBy = _data["matchingBy"];
            this.matchingWith = _data["matchingWith"];
            this.description = _data["description"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(MatchingItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyCashFlowMatchingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCashFlowMatchingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchingBy"] = this.matchingBy;
        data["matchingWith"] = this.matchingWith;
        data["description"] = this.description;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CompanyCashFlowMatchingDto {
        const json = this.toJSON();
        let result = new CompanyCashFlowMatchingDto();
        result.init(json);
        return result;
    }
}

export interface ICompanyCashFlowMatchingDto {
    matchingBy: string | undefined;
    matchingWith: string | undefined;
    description: string | undefined;
    items: MatchingItemDto[] | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ProvinceDto implements IProvinceDto {
    name: string | undefined;
    id: number;

    constructor(data?: IProvinceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProvinceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): ProvinceDto {
        const json = this.toJSON();
        let result = new ProvinceDto();
        result.init(json);
        return result;
    }
}

export interface IProvinceDto {
    name: string | undefined;
    id: number;
}

export class CountryDto implements ICountryDto {
    name: string | undefined;
    provinces: ProvinceDto[] | undefined;
    id: number;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["provinces"])) {
                this.provinces = [] as any;
                for (let item of _data["provinces"])
                    this.provinces.push(ProvinceDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.provinces)) {
            data["provinces"] = [];
            for (let item of this.provinces)
                data["provinces"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): CountryDto {
        const json = this.toJSON();
        let result = new CountryDto();
        result.init(json);
        return result;
    }
}

export interface ICountryDto {
    name: string | undefined;
    provinces: ProvinceDto[] | undefined;
    id: number;
}

export class UpdateCountryDto implements IUpdateCountryDto {
    name: string | undefined;
    provinces: ProvinceDto[] | undefined;
    id: number;

    constructor(data?: IUpdateCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["provinces"])) {
                this.provinces = [] as any;
                for (let item of _data["provinces"])
                    this.provinces.push(ProvinceDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.provinces)) {
            data["provinces"] = [];
            for (let item of this.provinces)
                data["provinces"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCountryDto {
        const json = this.toJSON();
        let result = new UpdateCountryDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCountryDto {
    name: string | undefined;
    provinces: ProvinceDto[] | undefined;
    id: number;
}

export class CreateCountryDto implements ICreateCountryDto {
    name: string | undefined;
    provinces: ProvinceDto[] | undefined;

    constructor(data?: ICreateCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["provinces"])) {
                this.provinces = [] as any;
                for (let item of _data["provinces"])
                    this.provinces.push(ProvinceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.provinces)) {
            data["provinces"] = [];
            for (let item of this.provinces)
                data["provinces"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateCountryDto {
        const json = this.toJSON();
        let result = new CreateCountryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCountryDto {
    name: string | undefined;
    provinces: ProvinceDto[] | undefined;
}

export class UpdateCurrencyDto implements IUpdateCurrencyDto {
    name: string | undefined;
    isMainCurrency: boolean;
    id: number;

    constructor(data?: IUpdateCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isMainCurrency = _data["isMainCurrency"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isMainCurrency"] = this.isMainCurrency;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateCurrencyDto {
        const json = this.toJSON();
        let result = new UpdateCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateCurrencyDto {
    name: string | undefined;
    isMainCurrency: boolean;
    id: number;
}

export class CreateCurrencyDto implements ICreateCurrencyDto {
    name: string | undefined;
    isMainCurrency: boolean;

    constructor(data?: ICreateCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isMainCurrency = _data["isMainCurrency"];
        }
    }

    static fromJS(data: any): CreateCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isMainCurrency"] = this.isMainCurrency;
        return data;
    }

    clone(): CreateCurrencyDto {
        const json = this.toJSON();
        let result = new CreateCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateCurrencyDto {
    name: string | undefined;
    isMainCurrency: boolean;
}

export class CustomerDto implements ICustomerDto {
    name: string | undefined;
    address: string | undefined;
    phoneNumber: string | undefined;
    identificationNumber: string | undefined;
    id: number;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.identificationNumber = _data["identificationNumber"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["identificationNumber"] = this.identificationNumber;
        data["id"] = this.id;
        return data;
    }

    clone(): CustomerDto {
        const json = this.toJSON();
        let result = new CustomerDto();
        result.init(json);
        return result;
    }
}

export interface ICustomerDto {
    name: string | undefined;
    address: string | undefined;
    phoneNumber: string | undefined;
    identificationNumber: string | undefined;
    id: number;
}

export class FileUploadDto implements IFileUploadDto {
    fileName: string | undefined;
    filePath: string | undefined;
    fileSize: string | undefined;
    fileType: string | undefined;
    fileAsBase64: string | undefined;
    fileAsByteArray: string | undefined;

    constructor(data?: IFileUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.filePath = _data["filePath"];
            this.fileSize = _data["fileSize"];
            this.fileType = _data["fileType"];
            this.fileAsBase64 = _data["fileAsBase64"];
            this.fileAsByteArray = _data["fileAsByteArray"];
        }
    }

    static fromJS(data: any): FileUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["filePath"] = this.filePath;
        data["fileSize"] = this.fileSize;
        data["fileType"] = this.fileType;
        data["fileAsBase64"] = this.fileAsBase64;
        data["fileAsByteArray"] = this.fileAsByteArray;
        return data;
    }

    clone(): FileUploadDto {
        const json = this.toJSON();
        let result = new FileUploadDto();
        result.init(json);
        return result;
    }
}

export interface IFileUploadDto {
    fileName: string | undefined;
    filePath: string | undefined;
    fileSize: string | undefined;
    fileType: string | undefined;
    fileAsBase64: string | undefined;
    fileAsByteArray: string | undefined;
}

export class CreateExchangeCurrencyDto implements ICreateExchangeCurrencyDto {
    number: number;
    amountOfFirstCurrency: number;
    amoutOfSecondCurrency: number;
    paidAmountOfFirstCurrency: number;
    receivedAmountOfFirstCurrency: number;
    paidAmountOfSecondCurrency: number;
    receivedAmountOfSecondCurrency: number;
    exchangePrice: number;
    paymentType: number;
    actionType: number;
    note: string | undefined;
    date: string | undefined;
    firstCurrencyId: number | undefined;
    secondCurrencyId: number | undefined;
    mainCurrencyId: number | undefined;
    clientId: number | undefined;
    companyId: number | undefined;

    constructor(data?: ICreateExchangeCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.amountOfFirstCurrency = _data["amountOfFirstCurrency"];
            this.amoutOfSecondCurrency = _data["amoutOfSecondCurrency"];
            this.paidAmountOfFirstCurrency = _data["paidAmountOfFirstCurrency"];
            this.receivedAmountOfFirstCurrency = _data["receivedAmountOfFirstCurrency"];
            this.paidAmountOfSecondCurrency = _data["paidAmountOfSecondCurrency"];
            this.receivedAmountOfSecondCurrency = _data["receivedAmountOfSecondCurrency"];
            this.exchangePrice = _data["exchangePrice"];
            this.paymentType = _data["paymentType"];
            this.actionType = _data["actionType"];
            this.note = _data["note"];
            this.date = _data["date"];
            this.firstCurrencyId = _data["firstCurrencyId"];
            this.secondCurrencyId = _data["secondCurrencyId"];
            this.mainCurrencyId = _data["mainCurrencyId"];
            this.clientId = _data["clientId"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): CreateExchangeCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExchangeCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["amountOfFirstCurrency"] = this.amountOfFirstCurrency;
        data["amoutOfSecondCurrency"] = this.amoutOfSecondCurrency;
        data["paidAmountOfFirstCurrency"] = this.paidAmountOfFirstCurrency;
        data["receivedAmountOfFirstCurrency"] = this.receivedAmountOfFirstCurrency;
        data["paidAmountOfSecondCurrency"] = this.paidAmountOfSecondCurrency;
        data["receivedAmountOfSecondCurrency"] = this.receivedAmountOfSecondCurrency;
        data["exchangePrice"] = this.exchangePrice;
        data["paymentType"] = this.paymentType;
        data["actionType"] = this.actionType;
        data["note"] = this.note;
        data["date"] = this.date;
        data["firstCurrencyId"] = this.firstCurrencyId;
        data["secondCurrencyId"] = this.secondCurrencyId;
        data["mainCurrencyId"] = this.mainCurrencyId;
        data["clientId"] = this.clientId;
        data["companyId"] = this.companyId;
        return data;
    }

    clone(): CreateExchangeCurrencyDto {
        const json = this.toJSON();
        let result = new CreateExchangeCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateExchangeCurrencyDto {
    number: number;
    amountOfFirstCurrency: number;
    amoutOfSecondCurrency: number;
    paidAmountOfFirstCurrency: number;
    receivedAmountOfFirstCurrency: number;
    paidAmountOfSecondCurrency: number;
    receivedAmountOfSecondCurrency: number;
    exchangePrice: number;
    paymentType: number;
    actionType: number;
    note: string | undefined;
    date: string | undefined;
    firstCurrencyId: number | undefined;
    secondCurrencyId: number | undefined;
    mainCurrencyId: number | undefined;
    clientId: number | undefined;
    companyId: number | undefined;
}

export class UpdateExchangeCurrencyDto implements IUpdateExchangeCurrencyDto {
    number: number;
    amountOfFirstCurrency: number;
    amoutOfSecondCurrency: number;
    paidAmountOfFirstCurrency: number;
    receivedAmountOfFirstCurrency: number;
    paidAmountOfSecondCurrency: number;
    receivedAmountOfSecondCurrency: number;
    exchangePrice: number;
    paymentType: number;
    actionType: number;
    note: string | undefined;
    date: string | undefined;
    firstCurrencyId: number | undefined;
    secondCurrencyId: number | undefined;
    mainCurrencyId: number | undefined;
    clientId: number | undefined;
    companyId: number | undefined;
    id: number;

    constructor(data?: IUpdateExchangeCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.amountOfFirstCurrency = _data["amountOfFirstCurrency"];
            this.amoutOfSecondCurrency = _data["amoutOfSecondCurrency"];
            this.paidAmountOfFirstCurrency = _data["paidAmountOfFirstCurrency"];
            this.receivedAmountOfFirstCurrency = _data["receivedAmountOfFirstCurrency"];
            this.paidAmountOfSecondCurrency = _data["paidAmountOfSecondCurrency"];
            this.receivedAmountOfSecondCurrency = _data["receivedAmountOfSecondCurrency"];
            this.exchangePrice = _data["exchangePrice"];
            this.paymentType = _data["paymentType"];
            this.actionType = _data["actionType"];
            this.note = _data["note"];
            this.date = _data["date"];
            this.firstCurrencyId = _data["firstCurrencyId"];
            this.secondCurrencyId = _data["secondCurrencyId"];
            this.mainCurrencyId = _data["mainCurrencyId"];
            this.clientId = _data["clientId"];
            this.companyId = _data["companyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateExchangeCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExchangeCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["amountOfFirstCurrency"] = this.amountOfFirstCurrency;
        data["amoutOfSecondCurrency"] = this.amoutOfSecondCurrency;
        data["paidAmountOfFirstCurrency"] = this.paidAmountOfFirstCurrency;
        data["receivedAmountOfFirstCurrency"] = this.receivedAmountOfFirstCurrency;
        data["paidAmountOfSecondCurrency"] = this.paidAmountOfSecondCurrency;
        data["receivedAmountOfSecondCurrency"] = this.receivedAmountOfSecondCurrency;
        data["exchangePrice"] = this.exchangePrice;
        data["paymentType"] = this.paymentType;
        data["actionType"] = this.actionType;
        data["note"] = this.note;
        data["date"] = this.date;
        data["firstCurrencyId"] = this.firstCurrencyId;
        data["secondCurrencyId"] = this.secondCurrencyId;
        data["mainCurrencyId"] = this.mainCurrencyId;
        data["clientId"] = this.clientId;
        data["companyId"] = this.companyId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateExchangeCurrencyDto {
        const json = this.toJSON();
        let result = new UpdateExchangeCurrencyDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateExchangeCurrencyDto {
    number: number;
    amountOfFirstCurrency: number;
    amoutOfSecondCurrency: number;
    paidAmountOfFirstCurrency: number;
    receivedAmountOfFirstCurrency: number;
    paidAmountOfSecondCurrency: number;
    receivedAmountOfSecondCurrency: number;
    exchangePrice: number;
    paymentType: number;
    actionType: number;
    note: string | undefined;
    date: string | undefined;
    firstCurrencyId: number | undefined;
    secondCurrencyId: number | undefined;
    mainCurrencyId: number | undefined;
    clientId: number | undefined;
    companyId: number | undefined;
    id: number;
}

export class ExchangeCurrencyDataManagerRequest implements IExchangeCurrencyDataManagerRequest {
    fromDate: string | undefined;
    toDate: string | undefined;
    paymentType: number | undefined;
    actionType: number | undefined;
    companyId: number | undefined;
    clientId: number | undefined;
    currencyId: number | undefined;
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;

    constructor(data?: IExchangeCurrencyDataManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            this.paymentType = _data["paymentType"];
            this.actionType = _data["actionType"];
            this.companyId = _data["companyId"];
            this.clientId = _data["clientId"];
            this.currencyId = _data["currencyId"];
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.antiForgery = _data["antiForgery"];
            this.requiresCounts = _data["requiresCounts"];
            this.table = _data["table"];
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group.push(item);
            }
            if (Array.isArray(_data["select"])) {
                this.select = [] as any;
                for (let item of _data["select"])
                    this.select.push(item);
            }
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand.push(item);
            }
            if (Array.isArray(_data["sorted"])) {
                this.sorted = [] as any;
                for (let item of _data["sorted"])
                    this.sorted.push(Sort.fromJS(item));
            }
            if (Array.isArray(_data["search"])) {
                this.search = [] as any;
                for (let item of _data["search"])
                    this.search.push(SearchFilter.fromJS(item));
            }
            if (Array.isArray(_data["where"])) {
                this.where = [] as any;
                for (let item of _data["where"])
                    this.where.push(WhereFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates.push(Aggregate.fromJS(item));
            }
            this.onDemandGroupInfo = _data["onDemandGroupInfo"] ? OnDemandGroupInfo.fromJS(_data["onDemandGroupInfo"]) : <any>undefined;
            this.isLazyLoad = _data["isLazyLoad"];
        }
    }

    static fromJS(data: any): ExchangeCurrencyDataManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangeCurrencyDataManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        data["paymentType"] = this.paymentType;
        data["actionType"] = this.actionType;
        data["companyId"] = this.companyId;
        data["clientId"] = this.clientId;
        data["currencyId"] = this.currencyId;
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["antiForgery"] = this.antiForgery;
        data["requiresCounts"] = this.requiresCounts;
        data["table"] = this.table;
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.select)) {
            data["select"] = [];
            for (let item of this.select)
                data["select"].push(item);
        }
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.sorted)) {
            data["sorted"] = [];
            for (let item of this.sorted)
                data["sorted"].push(item.toJSON());
        }
        if (Array.isArray(this.search)) {
            data["search"] = [];
            for (let item of this.search)
                data["search"].push(item.toJSON());
        }
        if (Array.isArray(this.where)) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["onDemandGroupInfo"] = this.onDemandGroupInfo ? this.onDemandGroupInfo.toJSON() : <any>undefined;
        data["isLazyLoad"] = this.isLazyLoad;
        return data;
    }

    clone(): ExchangeCurrencyDataManagerRequest {
        const json = this.toJSON();
        let result = new ExchangeCurrencyDataManagerRequest();
        result.init(json);
        return result;
    }
}

export interface IExchangeCurrencyDataManagerRequest {
    fromDate: string | undefined;
    toDate: string | undefined;
    paymentType: number | undefined;
    actionType: number | undefined;
    companyId: number | undefined;
    clientId: number | undefined;
    currencyId: number | undefined;
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;
}

export class ExchangePriceDto implements IExchangePriceDto {
    mainPrice: number | undefined;
    purchasingPrice: number | undefined;
    sellingPrice: number | undefined;
    currencyId: number | undefined;
    currency: CurrencyDto;
    id: number;

    constructor(data?: IExchangePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainPrice = _data["mainPrice"];
            this.purchasingPrice = _data["purchasingPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExchangePriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainPrice"] = this.mainPrice;
        data["purchasingPrice"] = this.purchasingPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ExchangePriceDto {
        const json = this.toJSON();
        let result = new ExchangePriceDto();
        result.init(json);
        return result;
    }
}

export interface IExchangePriceDto {
    mainPrice: number | undefined;
    purchasingPrice: number | undefined;
    sellingPrice: number | undefined;
    currencyId: number | undefined;
    currency: CurrencyDto;
    id: number;
}

export class UpdateExchangePriceDto implements IUpdateExchangePriceDto {
    mainPrice: number | undefined;
    purchasingPrice: number | undefined;
    sellingPrice: number | undefined;
    currencyId: number;
    id: number;

    constructor(data?: IUpdateExchangePriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mainPrice = _data["mainPrice"];
            this.purchasingPrice = _data["purchasingPrice"];
            this.sellingPrice = _data["sellingPrice"];
            this.currencyId = _data["currencyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateExchangePriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExchangePriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainPrice"] = this.mainPrice;
        data["purchasingPrice"] = this.purchasingPrice;
        data["sellingPrice"] = this.sellingPrice;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateExchangePriceDto {
        const json = this.toJSON();
        let result = new UpdateExchangePriceDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateExchangePriceDto {
    mainPrice: number | undefined;
    purchasingPrice: number | undefined;
    sellingPrice: number | undefined;
    currencyId: number;
    id: number;
}

export class ExpenseDto implements IExpenseDto {
    name: string | undefined;
    id: number;

    constructor(data?: IExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): ExpenseDto {
        const json = this.toJSON();
        let result = new ExpenseDto();
        result.init(json);
        return result;
    }
}

export interface IExpenseDto {
    name: string | undefined;
    id: number;
}

export class UpdateExpenseDto implements IUpdateExpenseDto {
    name: string | undefined;
    id: number;

    constructor(data?: IUpdateExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateExpenseDto {
        const json = this.toJSON();
        let result = new UpdateExpenseDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateExpenseDto {
    name: string | undefined;
    id: number;
}

export class CreateExpenseDto implements ICreateExpenseDto {
    name: string | undefined;

    constructor(data?: ICreateExpenseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateExpenseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExpenseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): CreateExpenseDto {
        const json = this.toJSON();
        let result = new CreateExpenseDto();
        result.init(json);
        return result;
    }
}

export interface ICreateExpenseDto {
    name: string | undefined;
}

export class CheckPasswordInput implements ICheckPasswordInput {
    password: string | undefined;

    constructor(data?: ICheckPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CheckPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        return data;
    }

    clone(): CheckPasswordInput {
        const json = this.toJSON();
        let result = new CheckPasswordInput();
        result.init(json);
        return result;
    }
}

export interface ICheckPasswordInput {
    password: string | undefined;
}

export class CheckPasswordOutput implements ICheckPasswordOutput {
    success: boolean;

    constructor(data?: ICheckPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): CheckPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data;
    }

    clone(): CheckPasswordOutput {
        const json = this.toJSON();
        let result = new CheckPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface ICheckPasswordOutput {
    success: boolean;
}

export class GeneralSettingDto implements IGeneralSettingDto {
    companyName: string | undefined;
    dbSuffex: string | undefined;
    editPassword: string | undefined;
    id: number;

    constructor(data?: IGeneralSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyName = _data["companyName"];
            this.dbSuffex = _data["dbSuffex"];
            this.editPassword = _data["editPassword"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GeneralSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyName"] = this.companyName;
        data["dbSuffex"] = this.dbSuffex;
        data["editPassword"] = this.editPassword;
        data["id"] = this.id;
        return data;
    }

    clone(): GeneralSettingDto {
        const json = this.toJSON();
        let result = new GeneralSettingDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingDto {
    companyName: string | undefined;
    dbSuffex: string | undefined;
    editPassword: string | undefined;
    id: number;
}

export class IncomeDto implements IIncomeDto {
    name: string | undefined;
    id: number;

    constructor(data?: IIncomeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IncomeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): IncomeDto {
        const json = this.toJSON();
        let result = new IncomeDto();
        result.init(json);
        return result;
    }
}

export interface IIncomeDto {
    name: string | undefined;
    id: number;
}

export class UpdateIncomeDto implements IUpdateIncomeDto {
    name: string | undefined;
    id: number;

    constructor(data?: IUpdateIncomeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UpdateIncomeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateIncomeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): UpdateIncomeDto {
        const json = this.toJSON();
        let result = new UpdateIncomeDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateIncomeDto {
    name: string | undefined;
    id: number;
}

export class CreateIncomeDto implements ICreateIncomeDto {
    name: string | undefined;

    constructor(data?: ICreateIncomeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateIncomeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateIncomeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }

    clone(): CreateIncomeDto {
        const json = this.toJSON();
        let result = new CreateIncomeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateIncomeDto {
    name: string | undefined;
}

export class IncomeTransferDetailDto implements IIncomeTransferDetailDto {
    index: number;
    status: number;
    toCompanyId: number | undefined;
    toClientId: number | undefined;
    currencyId: number;
    beneficiaryId: number | undefined;
    beneficiary: CustomerDto;
    senderId: number | undefined;
    sender: CustomerDto;
    paymentType: number;
    amount: number;
    commission: number;
    companyCommission: number;
    clientCommission: number;
    id: number;

    constructor(data?: IIncomeTransferDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.status = _data["status"];
            this.toCompanyId = _data["toCompanyId"];
            this.toClientId = _data["toClientId"];
            this.currencyId = _data["currencyId"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiary = _data["beneficiary"] ? CustomerDto.fromJS(_data["beneficiary"]) : <any>undefined;
            this.senderId = _data["senderId"];
            this.sender = _data["sender"] ? CustomerDto.fromJS(_data["sender"]) : <any>undefined;
            this.paymentType = _data["paymentType"];
            this.amount = _data["amount"];
            this.commission = _data["commission"];
            this.companyCommission = _data["companyCommission"];
            this.clientCommission = _data["clientCommission"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IncomeTransferDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeTransferDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["status"] = this.status;
        data["toCompanyId"] = this.toCompanyId;
        data["toClientId"] = this.toClientId;
        data["currencyId"] = this.currencyId;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiary"] = this.beneficiary ? this.beneficiary.toJSON() : <any>undefined;
        data["senderId"] = this.senderId;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["paymentType"] = this.paymentType;
        data["amount"] = this.amount;
        data["commission"] = this.commission;
        data["companyCommission"] = this.companyCommission;
        data["clientCommission"] = this.clientCommission;
        data["id"] = this.id;
        return data;
    }

    clone(): IncomeTransferDetailDto {
        const json = this.toJSON();
        let result = new IncomeTransferDetailDto();
        result.init(json);
        return result;
    }
}

export interface IIncomeTransferDetailDto {
    index: number;
    status: number;
    toCompanyId: number | undefined;
    toClientId: number | undefined;
    currencyId: number;
    beneficiaryId: number | undefined;
    beneficiary: CustomerDto;
    senderId: number | undefined;
    sender: CustomerDto;
    paymentType: number;
    amount: number;
    commission: number;
    companyCommission: number;
    clientCommission: number;
    id: number;
}

export class IncomeTransferDto implements IIncomeTransferDto {
    number: number;
    date: string | undefined;
    note: string | undefined;
    companyId: number | undefined;
    incomeTransferDetails: IncomeTransferDetailDto[] | undefined;
    id: number;

    constructor(data?: IIncomeTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.date = _data["date"];
            this.note = _data["note"];
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["incomeTransferDetails"])) {
                this.incomeTransferDetails = [] as any;
                for (let item of _data["incomeTransferDetails"])
                    this.incomeTransferDetails.push(IncomeTransferDetailDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IncomeTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["date"] = this.date;
        data["note"] = this.note;
        data["companyId"] = this.companyId;
        if (Array.isArray(this.incomeTransferDetails)) {
            data["incomeTransferDetails"] = [];
            for (let item of this.incomeTransferDetails)
                data["incomeTransferDetails"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): IncomeTransferDto {
        const json = this.toJSON();
        let result = new IncomeTransferDto();
        result.init(json);
        return result;
    }
}

export interface IIncomeTransferDto {
    number: number;
    date: string | undefined;
    note: string | undefined;
    companyId: number | undefined;
    incomeTransferDetails: IncomeTransferDetailDto[] | undefined;
    id: number;
}

export class IncomeTransferDetailChangeStatusInput implements IIncomeTransferDetailChangeStatusInput {
    status: number;
    id: number;

    constructor(data?: IIncomeTransferDetailChangeStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IncomeTransferDetailChangeStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeTransferDetailChangeStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["id"] = this.id;
        return data;
    }

    clone(): IncomeTransferDetailChangeStatusInput {
        const json = this.toJSON();
        let result = new IncomeTransferDetailChangeStatusInput();
        result.init(json);
        return result;
    }
}

export interface IIncomeTransferDetailChangeStatusInput {
    status: number;
    id: number;
}

export class MigrationOutput implements IMigrationOutput {
    success: boolean;
    message: string | undefined;

    constructor(data?: IMigrationOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): MigrationOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MigrationOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["message"] = this.message;
        return data;
    }

    clone(): MigrationOutput {
        const json = this.toJSON();
        let result = new MigrationOutput();
        result.init(json);
        return result;
    }
}

export interface IMigrationOutput {
    success: boolean;
    message: string | undefined;
}

export class ClearDatabaseOutput implements IClearDatabaseOutput {
    success: boolean;

    constructor(data?: IClearDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): ClearDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ClearDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data;
    }

    clone(): ClearDatabaseOutput {
        const json = this.toJSON();
        let result = new ClearDatabaseOutput();
        result.init(json);
        return result;
    }
}

export interface IClearDatabaseOutput {
    success: boolean;
}

export class OutgoingTransferDto implements IOutgoingTransferDto {
    number: number;
    currencyId: number;
    beneficiaryId: number | undefined;
    senderId: number | undefined;
    paymentType: number;
    amount: number;
    commission: number;
    companyCommission: number;
    clientCommission: number;
    date: string | undefined;
    toCompanyId: number;
    countryId: number;
    fromCompanyId: number | undefined;
    fromClientId: number | undefined;
    treasuryId: number | undefined;
    receivedAmount: number;
    instrumentNo: string | undefined;
    reason: string | undefined;
    note: string | undefined;
    beneficiary: CustomerDto;
    sender: CustomerDto;
    images: FileUploadDto[] | undefined;
    id: number;

    constructor(data?: IOutgoingTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.currencyId = _data["currencyId"];
            this.beneficiaryId = _data["beneficiaryId"];
            this.senderId = _data["senderId"];
            this.paymentType = _data["paymentType"];
            this.amount = _data["amount"];
            this.commission = _data["commission"];
            this.companyCommission = _data["companyCommission"];
            this.clientCommission = _data["clientCommission"];
            this.date = _data["date"];
            this.toCompanyId = _data["toCompanyId"];
            this.countryId = _data["countryId"];
            this.fromCompanyId = _data["fromCompanyId"];
            this.fromClientId = _data["fromClientId"];
            this.treasuryId = _data["treasuryId"];
            this.receivedAmount = _data["receivedAmount"];
            this.instrumentNo = _data["instrumentNo"];
            this.reason = _data["reason"];
            this.note = _data["note"];
            this.beneficiary = _data["beneficiary"] ? CustomerDto.fromJS(_data["beneficiary"]) : <any>undefined;
            this.sender = _data["sender"] ? CustomerDto.fromJS(_data["sender"]) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images.push(FileUploadDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OutgoingTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new OutgoingTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["currencyId"] = this.currencyId;
        data["beneficiaryId"] = this.beneficiaryId;
        data["senderId"] = this.senderId;
        data["paymentType"] = this.paymentType;
        data["amount"] = this.amount;
        data["commission"] = this.commission;
        data["companyCommission"] = this.companyCommission;
        data["clientCommission"] = this.clientCommission;
        data["date"] = this.date;
        data["toCompanyId"] = this.toCompanyId;
        data["countryId"] = this.countryId;
        data["fromCompanyId"] = this.fromCompanyId;
        data["fromClientId"] = this.fromClientId;
        data["treasuryId"] = this.treasuryId;
        data["receivedAmount"] = this.receivedAmount;
        data["instrumentNo"] = this.instrumentNo;
        data["reason"] = this.reason;
        data["note"] = this.note;
        data["beneficiary"] = this.beneficiary ? this.beneficiary.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }

    clone(): OutgoingTransferDto {
        const json = this.toJSON();
        let result = new OutgoingTransferDto();
        result.init(json);
        return result;
    }
}

export interface IOutgoingTransferDto {
    number: number;
    currencyId: number;
    beneficiaryId: number | undefined;
    senderId: number | undefined;
    paymentType: number;
    amount: number;
    commission: number;
    companyCommission: number;
    clientCommission: number;
    date: string | undefined;
    toCompanyId: number;
    countryId: number;
    fromCompanyId: number | undefined;
    fromClientId: number | undefined;
    treasuryId: number | undefined;
    receivedAmount: number;
    instrumentNo: string | undefined;
    reason: string | undefined;
    note: string | undefined;
    beneficiary: CustomerDto;
    sender: CustomerDto;
    images: FileUploadDto[] | undefined;
    id: number;
}

export class TreasuryDto implements ITreasuryDto {
    name: string | undefined;
    id: number;

    constructor(data?: ITreasuryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TreasuryDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): TreasuryDto {
        const json = this.toJSON();
        let result = new TreasuryDto();
        result.init(json);
        return result;
    }
}

export interface ITreasuryDto {
    name: string | undefined;
    id: number;
}

export class ReadOutgoingTransferDto implements IReadOutgoingTransferDto {
    number: number;
    paymentType: number;
    amount: number;
    commission: number;
    companyCommission: number;
    clientCommission: number;
    date: string | undefined;
    receivedAmount: number;
    instrumentNo: string | undefined;
    reason: string | undefined;
    note: string | undefined;
    countryId: number;
    country: CountryDto;
    currencyId: number;
    currency: CurrencyDto;
    treasuryId: number | undefined;
    treasury: TreasuryDto;
    beneficiaryId: number | undefined;
    beneficiary: CustomerDto;
    senderId: number | undefined;
    sender: CustomerDto;
    fromCompanyId: number | undefined;
    fromCompany: CompanyDto;
    toCompanyId: number | undefined;
    toCompany: CompanyDto;
    fromClientId: number | undefined;
    fromClient: ClientDto;
    id: number;

    constructor(data?: IReadOutgoingTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.paymentType = _data["paymentType"];
            this.amount = _data["amount"];
            this.commission = _data["commission"];
            this.companyCommission = _data["companyCommission"];
            this.clientCommission = _data["clientCommission"];
            this.date = _data["date"];
            this.receivedAmount = _data["receivedAmount"];
            this.instrumentNo = _data["instrumentNo"];
            this.reason = _data["reason"];
            this.note = _data["note"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.treasuryId = _data["treasuryId"];
            this.treasury = _data["treasury"] ? TreasuryDto.fromJS(_data["treasury"]) : <any>undefined;
            this.beneficiaryId = _data["beneficiaryId"];
            this.beneficiary = _data["beneficiary"] ? CustomerDto.fromJS(_data["beneficiary"]) : <any>undefined;
            this.senderId = _data["senderId"];
            this.sender = _data["sender"] ? CustomerDto.fromJS(_data["sender"]) : <any>undefined;
            this.fromCompanyId = _data["fromCompanyId"];
            this.fromCompany = _data["fromCompany"] ? CompanyDto.fromJS(_data["fromCompany"]) : <any>undefined;
            this.toCompanyId = _data["toCompanyId"];
            this.toCompany = _data["toCompany"] ? CompanyDto.fromJS(_data["toCompany"]) : <any>undefined;
            this.fromClientId = _data["fromClientId"];
            this.fromClient = _data["fromClient"] ? ClientDto.fromJS(_data["fromClient"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ReadOutgoingTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReadOutgoingTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["paymentType"] = this.paymentType;
        data["amount"] = this.amount;
        data["commission"] = this.commission;
        data["companyCommission"] = this.companyCommission;
        data["clientCommission"] = this.clientCommission;
        data["date"] = this.date;
        data["receivedAmount"] = this.receivedAmount;
        data["instrumentNo"] = this.instrumentNo;
        data["reason"] = this.reason;
        data["note"] = this.note;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["treasuryId"] = this.treasuryId;
        data["treasury"] = this.treasury ? this.treasury.toJSON() : <any>undefined;
        data["beneficiaryId"] = this.beneficiaryId;
        data["beneficiary"] = this.beneficiary ? this.beneficiary.toJSON() : <any>undefined;
        data["senderId"] = this.senderId;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["fromCompanyId"] = this.fromCompanyId;
        data["fromCompany"] = this.fromCompany ? this.fromCompany.toJSON() : <any>undefined;
        data["toCompanyId"] = this.toCompanyId;
        data["toCompany"] = this.toCompany ? this.toCompany.toJSON() : <any>undefined;
        data["fromClientId"] = this.fromClientId;
        data["fromClient"] = this.fromClient ? this.fromClient.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): ReadOutgoingTransferDto {
        const json = this.toJSON();
        let result = new ReadOutgoingTransferDto();
        result.init(json);
        return result;
    }
}

export interface IReadOutgoingTransferDto {
    number: number;
    paymentType: number;
    amount: number;
    commission: number;
    companyCommission: number;
    clientCommission: number;
    date: string | undefined;
    receivedAmount: number;
    instrumentNo: string | undefined;
    reason: string | undefined;
    note: string | undefined;
    countryId: number;
    country: CountryDto;
    currencyId: number;
    currency: CurrencyDto;
    treasuryId: number | undefined;
    treasury: TreasuryDto;
    beneficiaryId: number | undefined;
    beneficiary: CustomerDto;
    senderId: number | undefined;
    sender: CustomerDto;
    fromCompanyId: number | undefined;
    fromCompany: CompanyDto;
    toCompanyId: number | undefined;
    toCompany: CompanyDto;
    fromClientId: number | undefined;
    fromClient: ClientDto;
    id: number;
}

export class ProvinceForDropdownDto implements IProvinceForDropdownDto {
    name: string | undefined;
    countryName: string | undefined;
    id: number;

    constructor(data?: IProvinceForDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.countryName = _data["countryName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProvinceForDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProvinceForDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["countryName"] = this.countryName;
        data["id"] = this.id;
        return data;
    }

    clone(): ProvinceForDropdownDto {
        const json = this.toJSON();
        let result = new ProvinceForDropdownDto();
        result.init(json);
        return result;
    }
}

export interface IProvinceForDropdownDto {
    name: string | undefined;
    countryName: string | undefined;
    id: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    dataAccess: number;
    grantedPermissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.dataAccess = _data["dataAccess"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["dataAccess"] = this.dataAccess;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    dataAccess: number;
    grantedPermissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    dataAccess: number;
    grantedPermissions: string[] | undefined;
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.dataAccess = _data["dataAccess"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["dataAccess"] = this.dataAccess;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    dataAccess: number;
    grantedPermissions: string[] | undefined;
    id: number;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    dataAccess: number;
    isStatic: boolean;
    id: number;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.dataAccess = _data["dataAccess"];
            this.isStatic = _data["isStatic"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["dataAccess"] = this.dataAccess;
        data["isStatic"] = this.isStatic;
        data["id"] = this.id;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    name: string;
    displayName: string;
    description: string | undefined;
    dataAccess: number;
    isStatic: boolean;
    id: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    totalCount: number;
    items: RoleDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? moment(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)[key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string]: boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    totalCount: number;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class TreasuryActionDto implements ITreasuryActionDto {
    number: number;
    actionType: number;
    date: string | undefined;
    mainAccount: number;
    currencyId: number | undefined;
    exchangePartyCompanyId: number | undefined;
    exchangePartyClientId: number | undefined;
    mainAccountCompanyId: number | undefined;
    mainAccountClientId: number | undefined;
    expenseId: number | undefined;
    incomeId: number | undefined;
    treasuryId: number | undefined;
    incomeTransferDetailId: number | undefined;
    amount: number;
    note: string | undefined;
    instrumentNo: string | undefined;
    identificationNumber: string | undefined;
    issuer: string | undefined;
    id: number;

    constructor(data?: ITreasuryActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.actionType = _data["actionType"];
            this.date = _data["date"];
            this.mainAccount = _data["mainAccount"];
            this.currencyId = _data["currencyId"];
            this.exchangePartyCompanyId = _data["exchangePartyCompanyId"];
            this.exchangePartyClientId = _data["exchangePartyClientId"];
            this.mainAccountCompanyId = _data["mainAccountCompanyId"];
            this.mainAccountClientId = _data["mainAccountClientId"];
            this.expenseId = _data["expenseId"];
            this.incomeId = _data["incomeId"];
            this.treasuryId = _data["treasuryId"];
            this.incomeTransferDetailId = _data["incomeTransferDetailId"];
            this.amount = _data["amount"];
            this.note = _data["note"];
            this.instrumentNo = _data["instrumentNo"];
            this.identificationNumber = _data["identificationNumber"];
            this.issuer = _data["issuer"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TreasuryActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["actionType"] = this.actionType;
        data["date"] = this.date;
        data["mainAccount"] = this.mainAccount;
        data["currencyId"] = this.currencyId;
        data["exchangePartyCompanyId"] = this.exchangePartyCompanyId;
        data["exchangePartyClientId"] = this.exchangePartyClientId;
        data["mainAccountCompanyId"] = this.mainAccountCompanyId;
        data["mainAccountClientId"] = this.mainAccountClientId;
        data["expenseId"] = this.expenseId;
        data["incomeId"] = this.incomeId;
        data["treasuryId"] = this.treasuryId;
        data["incomeTransferDetailId"] = this.incomeTransferDetailId;
        data["amount"] = this.amount;
        data["note"] = this.note;
        data["instrumentNo"] = this.instrumentNo;
        data["identificationNumber"] = this.identificationNumber;
        data["issuer"] = this.issuer;
        data["id"] = this.id;
        return data;
    }

    clone(): TreasuryActionDto {
        const json = this.toJSON();
        let result = new TreasuryActionDto();
        result.init(json);
        return result;
    }
}

export interface ITreasuryActionDto {
    number: number;
    actionType: number;
    date: string | undefined;
    mainAccount: number;
    currencyId: number | undefined;
    exchangePartyCompanyId: number | undefined;
    exchangePartyClientId: number | undefined;
    mainAccountCompanyId: number | undefined;
    mainAccountClientId: number | undefined;
    expenseId: number | undefined;
    incomeId: number | undefined;
    treasuryId: number | undefined;
    incomeTransferDetailId: number | undefined;
    amount: number;
    note: string | undefined;
    instrumentNo: string | undefined;
    identificationNumber: string | undefined;
    issuer: string | undefined;
    id: number;
}

export class ExchangePartyDto implements IExchangePartyDto {
    exchangePartyId: string | undefined;
    name: string | undefined;
    group: string | undefined;
    id: number;

    constructor(data?: IExchangePartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exchangePartyId = _data["exchangePartyId"];
            this.name = _data["name"];
            this.group = _data["group"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExchangePartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExchangePartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exchangePartyId"] = this.exchangePartyId;
        data["name"] = this.name;
        data["group"] = this.group;
        data["id"] = this.id;
        return data;
    }

    clone(): ExchangePartyDto {
        const json = this.toJSON();
        let result = new ExchangePartyDto();
        result.init(json);
        return result;
    }
}

export interface IExchangePartyDto {
    exchangePartyId: string | undefined;
    name: string | undefined;
    group: string | undefined;
    id: number;
}

export class PayDirectTransferInputDto implements IPayDirectTransferInputDto {
    treasuryAction: TreasuryActionDto;
    images: FileUploadDto[] | undefined;
    phoneNumber: string | undefined;

    constructor(data?: IPayDirectTransferInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.treasuryAction = _data["treasuryAction"] ? TreasuryActionDto.fromJS(_data["treasuryAction"]) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images.push(FileUploadDto.fromJS(item));
            }
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): PayDirectTransferInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayDirectTransferInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["treasuryAction"] = this.treasuryAction ? this.treasuryAction.toJSON() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }

    clone(): PayDirectTransferInputDto {
        const json = this.toJSON();
        let result = new PayDirectTransferInputDto();
        result.init(json);
        return result;
    }
}

export interface IPayDirectTransferInputDto {
    treasuryAction: TreasuryActionDto;
    images: FileUploadDto[] | undefined;
    phoneNumber: string | undefined;
}

export class TreasuryActionDataManagerRequest implements ITreasuryActionDataManagerRequest {
    number: number | undefined;
    currencyId: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    actionType: number | undefined;
    mainAccount: number | undefined;
    mainAccountCompanyId: number | undefined;
    mainAccountClientId: number | undefined;
    expenseId: number | undefined;
    incomeId: number | undefined;
    incomeTransferDetailId: number | undefined;
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;

    constructor(data?: ITreasuryActionDataManagerRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.currencyId = _data["currencyId"];
            this.fromDate = _data["fromDate"];
            this.toDate = _data["toDate"];
            this.actionType = _data["actionType"];
            this.mainAccount = _data["mainAccount"];
            this.mainAccountCompanyId = _data["mainAccountCompanyId"];
            this.mainAccountClientId = _data["mainAccountClientId"];
            this.expenseId = _data["expenseId"];
            this.incomeId = _data["incomeId"];
            this.incomeTransferDetailId = _data["incomeTransferDetailId"];
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.antiForgery = _data["antiForgery"];
            this.requiresCounts = _data["requiresCounts"];
            this.table = _data["table"];
            if (Array.isArray(_data["group"])) {
                this.group = [] as any;
                for (let item of _data["group"])
                    this.group.push(item);
            }
            if (Array.isArray(_data["select"])) {
                this.select = [] as any;
                for (let item of _data["select"])
                    this.select.push(item);
            }
            if (Array.isArray(_data["expand"])) {
                this.expand = [] as any;
                for (let item of _data["expand"])
                    this.expand.push(item);
            }
            if (Array.isArray(_data["sorted"])) {
                this.sorted = [] as any;
                for (let item of _data["sorted"])
                    this.sorted.push(Sort.fromJS(item));
            }
            if (Array.isArray(_data["search"])) {
                this.search = [] as any;
                for (let item of _data["search"])
                    this.search.push(SearchFilter.fromJS(item));
            }
            if (Array.isArray(_data["where"])) {
                this.where = [] as any;
                for (let item of _data["where"])
                    this.where.push(WhereFilter.fromJS(item));
            }
            if (Array.isArray(_data["aggregates"])) {
                this.aggregates = [] as any;
                for (let item of _data["aggregates"])
                    this.aggregates.push(Aggregate.fromJS(item));
            }
            this.onDemandGroupInfo = _data["onDemandGroupInfo"] ? OnDemandGroupInfo.fromJS(_data["onDemandGroupInfo"]) : <any>undefined;
            this.isLazyLoad = _data["isLazyLoad"];
        }
    }

    static fromJS(data: any): TreasuryActionDataManagerRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryActionDataManagerRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["currencyId"] = this.currencyId;
        data["fromDate"] = this.fromDate;
        data["toDate"] = this.toDate;
        data["actionType"] = this.actionType;
        data["mainAccount"] = this.mainAccount;
        data["mainAccountCompanyId"] = this.mainAccountCompanyId;
        data["mainAccountClientId"] = this.mainAccountClientId;
        data["expenseId"] = this.expenseId;
        data["incomeId"] = this.incomeId;
        data["incomeTransferDetailId"] = this.incomeTransferDetailId;
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["antiForgery"] = this.antiForgery;
        data["requiresCounts"] = this.requiresCounts;
        data["table"] = this.table;
        if (Array.isArray(this.group)) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        if (Array.isArray(this.select)) {
            data["select"] = [];
            for (let item of this.select)
                data["select"].push(item);
        }
        if (Array.isArray(this.expand)) {
            data["expand"] = [];
            for (let item of this.expand)
                data["expand"].push(item);
        }
        if (Array.isArray(this.sorted)) {
            data["sorted"] = [];
            for (let item of this.sorted)
                data["sorted"].push(item.toJSON());
        }
        if (Array.isArray(this.search)) {
            data["search"] = [];
            for (let item of this.search)
                data["search"].push(item.toJSON());
        }
        if (Array.isArray(this.where)) {
            data["where"] = [];
            for (let item of this.where)
                data["where"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregates)) {
            data["aggregates"] = [];
            for (let item of this.aggregates)
                data["aggregates"].push(item.toJSON());
        }
        data["onDemandGroupInfo"] = this.onDemandGroupInfo ? this.onDemandGroupInfo.toJSON() : <any>undefined;
        data["isLazyLoad"] = this.isLazyLoad;
        return data;
    }

    clone(): TreasuryActionDataManagerRequest {
        const json = this.toJSON();
        let result = new TreasuryActionDataManagerRequest();
        result.init(json);
        return result;
    }
}

export interface ITreasuryActionDataManagerRequest {
    number: number | undefined;
    currencyId: number | undefined;
    fromDate: string | undefined;
    toDate: string | undefined;
    actionType: number | undefined;
    mainAccount: number | undefined;
    mainAccountCompanyId: number | undefined;
    mainAccountClientId: number | undefined;
    expenseId: number | undefined;
    incomeId: number | undefined;
    incomeTransferDetailId: number | undefined;
    skip: number;
    take: number;
    antiForgery: string | undefined;
    requiresCounts: boolean;
    table: string | undefined;
    group: string[] | undefined;
    select: string[] | undefined;
    expand: string[] | undefined;
    sorted: Sort[] | undefined;
    search: SearchFilter[] | undefined;
    where: WhereFilter[] | undefined;
    aggregates: Aggregate[] | undefined;
    onDemandGroupInfo: OnDemandGroupInfo;
    isLazyLoad: boolean;
}

export class TreasuryActionStatementOutputDto implements ITreasuryActionStatementOutputDto {
    number: number;
    actionType: number;
    date: string | undefined;
    mainAccount: number;
    currencyId: number | undefined;
    currency: CurrencyDto;
    exchangePartyCompanyId: number | undefined;
    exchangePartyCompany: CompanyDto;
    exchangePartyClientId: number | undefined;
    exchangePartyClient: ClientDto;
    mainAccountCompanyId: number | undefined;
    mainAccountCompany: CompanyDto;
    mainAccountClientId: number | undefined;
    mainAccountClient: ClientDto;
    expenseId: number | undefined;
    expense: ExpenseDto;
    incomeId: number | undefined;
    income: IncomeDto;
    treasuryId: number | undefined;
    treasury: TreasuryDto;
    incomeTransferDetailId: number | undefined;
    incomeTransferDetail: IncomeTransferDetailDto;
    amount: number;
    note: string | undefined;
    instrumentNo: string | undefined;
    identificationNumber: string | undefined;
    issuer: string | undefined;
    id: number;

    constructor(data?: ITreasuryActionStatementOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.actionType = _data["actionType"];
            this.date = _data["date"];
            this.mainAccount = _data["mainAccount"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.exchangePartyCompanyId = _data["exchangePartyCompanyId"];
            this.exchangePartyCompany = _data["exchangePartyCompany"] ? CompanyDto.fromJS(_data["exchangePartyCompany"]) : <any>undefined;
            this.exchangePartyClientId = _data["exchangePartyClientId"];
            this.exchangePartyClient = _data["exchangePartyClient"] ? ClientDto.fromJS(_data["exchangePartyClient"]) : <any>undefined;
            this.mainAccountCompanyId = _data["mainAccountCompanyId"];
            this.mainAccountCompany = _data["mainAccountCompany"] ? CompanyDto.fromJS(_data["mainAccountCompany"]) : <any>undefined;
            this.mainAccountClientId = _data["mainAccountClientId"];
            this.mainAccountClient = _data["mainAccountClient"] ? ClientDto.fromJS(_data["mainAccountClient"]) : <any>undefined;
            this.expenseId = _data["expenseId"];
            this.expense = _data["expense"] ? ExpenseDto.fromJS(_data["expense"]) : <any>undefined;
            this.incomeId = _data["incomeId"];
            this.income = _data["income"] ? IncomeDto.fromJS(_data["income"]) : <any>undefined;
            this.treasuryId = _data["treasuryId"];
            this.treasury = _data["treasury"] ? TreasuryDto.fromJS(_data["treasury"]) : <any>undefined;
            this.incomeTransferDetailId = _data["incomeTransferDetailId"];
            this.incomeTransferDetail = _data["incomeTransferDetail"] ? IncomeTransferDetailDto.fromJS(_data["incomeTransferDetail"]) : <any>undefined;
            this.amount = _data["amount"];
            this.note = _data["note"];
            this.instrumentNo = _data["instrumentNo"];
            this.identificationNumber = _data["identificationNumber"];
            this.issuer = _data["issuer"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TreasuryActionStatementOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryActionStatementOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["actionType"] = this.actionType;
        data["date"] = this.date;
        data["mainAccount"] = this.mainAccount;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["exchangePartyCompanyId"] = this.exchangePartyCompanyId;
        data["exchangePartyCompany"] = this.exchangePartyCompany ? this.exchangePartyCompany.toJSON() : <any>undefined;
        data["exchangePartyClientId"] = this.exchangePartyClientId;
        data["exchangePartyClient"] = this.exchangePartyClient ? this.exchangePartyClient.toJSON() : <any>undefined;
        data["mainAccountCompanyId"] = this.mainAccountCompanyId;
        data["mainAccountCompany"] = this.mainAccountCompany ? this.mainAccountCompany.toJSON() : <any>undefined;
        data["mainAccountClientId"] = this.mainAccountClientId;
        data["mainAccountClient"] = this.mainAccountClient ? this.mainAccountClient.toJSON() : <any>undefined;
        data["expenseId"] = this.expenseId;
        data["expense"] = this.expense ? this.expense.toJSON() : <any>undefined;
        data["incomeId"] = this.incomeId;
        data["income"] = this.income ? this.income.toJSON() : <any>undefined;
        data["treasuryId"] = this.treasuryId;
        data["treasury"] = this.treasury ? this.treasury.toJSON() : <any>undefined;
        data["incomeTransferDetailId"] = this.incomeTransferDetailId;
        data["incomeTransferDetail"] = this.incomeTransferDetail ? this.incomeTransferDetail.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["note"] = this.note;
        data["instrumentNo"] = this.instrumentNo;
        data["identificationNumber"] = this.identificationNumber;
        data["issuer"] = this.issuer;
        data["id"] = this.id;
        return data;
    }

    clone(): TreasuryActionStatementOutputDto {
        const json = this.toJSON();
        let result = new TreasuryActionStatementOutputDto();
        result.init(json);
        return result;
    }
}

export interface ITreasuryActionStatementOutputDto {
    number: number;
    actionType: number;
    date: string | undefined;
    mainAccount: number;
    currencyId: number | undefined;
    currency: CurrencyDto;
    exchangePartyCompanyId: number | undefined;
    exchangePartyCompany: CompanyDto;
    exchangePartyClientId: number | undefined;
    exchangePartyClient: ClientDto;
    mainAccountCompanyId: number | undefined;
    mainAccountCompany: CompanyDto;
    mainAccountClientId: number | undefined;
    mainAccountClient: ClientDto;
    expenseId: number | undefined;
    expense: ExpenseDto;
    incomeId: number | undefined;
    income: IncomeDto;
    treasuryId: number | undefined;
    treasury: TreasuryDto;
    incomeTransferDetailId: number | undefined;
    incomeTransferDetail: IncomeTransferDetailDto;
    amount: number;
    note: string | undefined;
    instrumentNo: string | undefined;
    identificationNumber: string | undefined;
    issuer: string | undefined;
    id: number;
}

export class TreasuryBalanceDto implements ITreasuryBalanceDto {
    initilBalance: number;
    currencyId: number;
    currency: CurrencyDto;
    treasury: TreasuryDto;
    treasuryId: number;
    id: number;

    constructor(data?: ITreasuryBalanceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.initilBalance = _data["initilBalance"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.treasury = _data["treasury"] ? TreasuryDto.fromJS(_data["treasury"]) : <any>undefined;
            this.treasuryId = _data["treasuryId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TreasuryBalanceDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryBalanceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["initilBalance"] = this.initilBalance;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["treasury"] = this.treasury ? this.treasury.toJSON() : <any>undefined;
        data["treasuryId"] = this.treasuryId;
        data["id"] = this.id;
        return data;
    }

    clone(): TreasuryBalanceDto {
        const json = this.toJSON();
        let result = new TreasuryBalanceDto();
        result.init(json);
        return result;
    }
}

export interface ITreasuryBalanceDto {
    initilBalance: number;
    currencyId: number;
    currency: CurrencyDto;
    treasury: TreasuryDto;
    treasuryId: number;
    id: number;
}

export class TreasuryCashFlowDto implements ITreasuryCashFlowDto {
    name: string | undefined;
    treasuryId: number;
    balance: number;
    creatorUserId: number | undefined;
    creatorUser: string | undefined;
    date: moment.Moment | undefined;
    amount: number;
    currentBalance: number;
    transactionId: number;
    transactionType: number;
    matched: boolean;
    shaded: boolean | undefined;
    type: string | undefined;
    note: string | undefined;
    instrumentNo: string | undefined;
    currencyId: number;
    currency: CurrencyDto;
    cashFlowMatchingId: number | undefined;
    cashFlowMatching: CashFlowMatchingDto;
    id: number;

    constructor(data?: ITreasuryCashFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.treasuryId = _data["treasuryId"];
            this.balance = _data["balance"];
            this.creatorUserId = _data["creatorUserId"];
            this.creatorUser = _data["creatorUser"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.currentBalance = _data["currentBalance"];
            this.transactionId = _data["transactionId"];
            this.transactionType = _data["transactionType"];
            this.matched = _data["matched"];
            this.shaded = _data["shaded"];
            this.type = _data["type"];
            this.note = _data["note"];
            this.instrumentNo = _data["instrumentNo"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.cashFlowMatchingId = _data["cashFlowMatchingId"];
            this.cashFlowMatching = _data["cashFlowMatching"] ? CashFlowMatchingDto.fromJS(_data["cashFlowMatching"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TreasuryCashFlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreasuryCashFlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["treasuryId"] = this.treasuryId;
        data["balance"] = this.balance;
        data["creatorUserId"] = this.creatorUserId;
        data["creatorUser"] = this.creatorUser;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["currentBalance"] = this.currentBalance;
        data["transactionId"] = this.transactionId;
        data["transactionType"] = this.transactionType;
        data["matched"] = this.matched;
        data["shaded"] = this.shaded;
        data["type"] = this.type;
        data["note"] = this.note;
        data["instrumentNo"] = this.instrumentNo;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["cashFlowMatchingId"] = this.cashFlowMatchingId;
        data["cashFlowMatching"] = this.cashFlowMatching ? this.cashFlowMatching.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): TreasuryCashFlowDto {
        const json = this.toJSON();
        let result = new TreasuryCashFlowDto();
        result.init(json);
        return result;
    }
}

export interface ITreasuryCashFlowDto {
    name: string | undefined;
    treasuryId: number;
    balance: number;
    creatorUserId: number | undefined;
    creatorUser: string | undefined;
    date: moment.Moment | undefined;
    amount: number;
    currentBalance: number;
    transactionId: number;
    transactionType: number;
    matched: boolean;
    shaded: boolean | undefined;
    type: string | undefined;
    note: string | undefined;
    instrumentNo: string | undefined;
    currencyId: number;
    currency: CurrencyDto;
    cashFlowMatchingId: number | undefined;
    cashFlowMatching: CashFlowMatchingDto;
    id: number;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? moment(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    roleNames: string[] | undefined;
    id: number;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
}

export class ResetPasswordDto implements IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.adminPassword = _data["adminPassword"];
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["adminPassword"] = this.adminPassword;
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    adminPassword: string;
    userId: number;
    newPassword: string;
}

export class UserForDropdownDto implements IUserForDropdownDto {
    name: string | undefined;
    id: number;

    constructor(data?: IUserForDropdownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserForDropdownDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserForDropdownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["id"] = this.id;
        return data;
    }

    clone(): UserForDropdownDto {
        const json = this.toJSON();
        let result = new UserForDropdownDto();
        result.init(json);
        return result;
    }
}

export interface IUserForDropdownDto {
    name: string | undefined;
    id: number;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    totalCount: number;
    items: UserDto[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}